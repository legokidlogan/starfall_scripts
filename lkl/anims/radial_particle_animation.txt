--@name Radial Particle Animation
--@author legokidlogan
--@shared
--@include lkl/anims/holo_animation.txt
--@include lkl/math/hsv_math.txt
--@include lkl/math/vector_math.txt

--[[
    - A HoloAnimation which spawns holos which move radially inwards/outwards from the center.
    - Variables with 'start' or 'end' at the end of their names are values which will be interpolated between the start and end of the animation.
        - Due to how this operates, this class cannot have infinite-duration animations. Duration must be >= 0.
        - The interpolated value will be retrieved upon particle creation, and will not change afterwards for said particle.
    - Variables with 'begin' or 'finish' in their names are values which will be interpolated between the beginning and end of each particle's lifetime.
    - To reduce entity netowrking and server cpu usage, all particles will be created and simulated clientside.
        - This means that server-created anims will show nothing if replicateOnClient is false.
    - Cannot have an infinite duration.
--]]


if RadialParticleAnimation then return end

require( "lkl/anims/holo_animation.txt" )
require( "lkl/math/hsv_math.txt" )
require( "lkl/math/vector_math.txt" )


math.easeLinear = math.easeLinear or function( frac ) return frac end


RadialParticleAnimation = class( "RadialParticleAnimation", HoloAnimation )
local ThisClass = RadialParticleAnimation -- For readability

-- These can be changed on a per-instance basis, but only during initialization.
ThisClass.static.PARTICLE_LIMIT = 30

-- These can be changed on a per-instance basis. They have set/get functions, but the sheer quantity has led me to auto-generate them.
ThisClass.static.PARTICLE_ACTIVE_MIN_START = 1
ThisClass.static.PARTICLE_ACTIVE_MIN_END = 5
ThisClass.static.PARTICLE_ACTIVE_MAX_START = 15
ThisClass.static.PARTICLE_ACTIVE_MAX_END = 30
ThisClass.static.PARTICLE_ACTIVE_CHANCE_START = 0.05
ThisClass.static.PARTICLE_ACTIVE_CHANCE_END = 0.3
ThisClass.static.PARTICLE_DISTANCE_BEGIN_START = 20
ThisClass.static.PARTICLE_DISTANCE_BEGIN_END = 20
ThisClass.static.PARTICLE_DISTANCE_FINISH_START = -10
ThisClass.static.PARTICLE_DISTANCE_FINISH_END = -20
ThisClass.static.PARTICLE_DISTANCE_BEGIN_VARIANCE_START = 5 -- The beginning distance will be offset randomly by (-this, this)
ThisClass.static.PARTICLE_DISTANCE_BEGIN_VARIANCE_END = 5
ThisClass.static.PARTICLE_LIFETIME_START = 2
ThisClass.static.PARTICLE_LIFETIME_END = 0.25
ThisClass.static.PARTICLE_SCALE_BEGIN_START = Vector( 1, 1, 0.1 )
ThisClass.static.PARTICLE_SCALE_BEGIN_END = Vector( 1, 1, 0.1 )
ThisClass.static.PARTICLE_SCALE_FINISH_START = Vector( 1, 1, 1 )
ThisClass.static.PARTICLE_SCALE_FINISH_END = Vector( 1, 1, 4 )
ThisClass.static.PARTICLE_COLOR_BEGIN_START = Color( 255, 255, 255, 0 )
ThisClass.static.PARTICLE_COLOR_BEGIN_END = Color( 255, 255, 255, 0 )
ThisClass.static.PARTICLE_COLOR_FINISH_START = Color( 255, 255, 255, 255 )
ThisClass.static.PARTICLE_COLOR_FINISH_END = Color( 255, 255, 255, 255 )
ThisClass.static.PARTICLE_MODEL = "models/sprops/cylinders/size_2/cylinder_3x3.mdl"
ThisClass.static.PARTICLE_MATERIAL = "models/debug/debugwhite"
ThisClass.static.PARTICLE_FULLBRIGHT = true
ThisClass.static.PARTICLE_FOLLOW = true
ThisClass.static.PARTICLE_ANGLE = Angle( 90, 180, 180 )
ThisClass.static.INTERP_CLAMP_OVERALL = false
ThisClass.static.INTERP_CLAMP_PARTICLE_DISTANCE = false
ThisClass.static.INTERP_CLAMP_PARTICLE_SCALE = false
ThisClass.static.INTERP_CLAMP_PARTICLE_COLOR = false

-- These can be changed on a per-instance basis. They have manually-made set/get functions due to being more complex.
ThisClass.static.INTERP_EASE_OVERALL = "easeInOutQuad"
ThisClass.static.INTERP_EASE_PARTICLE_DISTANCE = "easeInCubic"
ThisClass.static.INTERP_EASE_PARTICLE_SCALE = "easeInCubic"
ThisClass.static.INTERP_EASE_PARTICLE_COLOR = "easeInCubic"

-- Default value overrides from parent classes
ThisClass.DURATION = 10
ThisClass.INIT_SYNC_DELAY = 0.1


local COLOR_EMPTY = Color( 0, 0, 0, 0 )
local VECTOR_ZERO = Vector( 0, 0, 0 )
local ANGLE_ZERO = Angle( 0, 0, 0 )

local resolveEaseFuncName
local lerpUnclamped

local mathClamp = math.clamp
local mathRand = math.rand
local mathFloor = math.floor
local mathMin = math.min
local mathMax = math.max


----- STATIC FUNCTIONS -----

function ThisClass:initialize( replicateOnClient, pos, ang, particleLimit, ... )
    particleLimit = particleLimit or self.class.PARTICLE_LIMIT

    ThisClass.super.initialize( self, replicateOnClient, pos, ang, particleLimit, ... )

    self._particleLimit = particleLimit
    self._groupedHolos.inactive = {}
    self._groupedHolos.active = {}

    self:setInterpEaseOverall( self.class.INTERP_EASE_OVERALL )
    self:setInterpEaseParticleDistance( self.class.INTERP_EASE_PARTICLE_DISTANCE )
    self:setInterpEaseParticleScale( self.class.INTERP_EASE_PARTICLE_SCALE )
    self:setInterpEaseParticleColor( self.class.INTERP_EASE_PARTICLE_COLOR )

    if SERVER then return end

    local holoModel = self:getParticleModel()

    for _ = 1, particleLimit do
        self:queueGroupedHolo(
            {
                Model = holoModel,
                StartHiddenByColor = true,
            },
            "inactive"
        )
    end
end


----- INSTANCE FUNCTIONS -----

function ThisClass:getParticleLimit()
    return self._particleLimit
end

function ThisClass:getInactiveParticleCount()
    return #self:getHoloGroup( "inactive" )
end

function ThisClass:getActiveParticleCount()
    return #self:getHoloGroup( "active" )
end

--[[
    - Sets the name of the easing function used while interpolating the overall animation.
    - Use :setInterpClampOverall() to set whether or not the easing result should be clamped between 0 and 1.

    funcName: (string)
        - The name of the function to use.
        - Must be the name of a function on the global math table. (e.g. "easeInQuart")
            - Has to take one argument and return one result. (e.g. "easeInOut" won't work since it has 3 args)
            - The function will be cached, so you can put something on the math table, call this function, then remove it.
                - Be careful with netowrking though, it has to exist on both realms.
        - Alternatively, it can be a string starting with "ls:" to use loadstring instead.
            - Much better for networking, but comes with the dangers of loadstring.
            - ex: "ls:function( frac ) return frac end"
--]]
function ThisClass:setInterpEaseOverall( funcName )
    if funcName == nil then funcName = self.class.INTERP_EASE_OVERALL end
    if funcName == self._interpEaseOverall then return end

    self._interpEaseOverallFunc = resolveEaseFuncName( funcName )
    self._interpEaseOverall = funcName
    self:syncProperty( "RadialParticleAnimation_InterpEaseOverall", funcName )
end

-- The name of the easing function used to ease interpolation of the overall animation.
function ThisClass:getInterpEaseOverall()
    return self._interpEaseOverall
end

-- The function used to ease interpolation of the overall animation.
function ThisClass:getInterpEaseOverallFunc()
    return self._interpEaseOverallFunc
end

-- Same as :setInterpEaseOverall(), but for how each particle moves radially over their lifetime.
function ThisClass:setInterpEaseParticleDistance( funcName )
    if funcName == nil then funcName = self.class.INTERP_EASE_PARTICLE_DISTANCE end
    if funcName == self._interpEaseParticleDistance then return end

    self._interpEaseParticleDistanceFunc = resolveEaseFuncName( funcName )
    self._interpEaseParticleDistance = funcName
    self:syncProperty( "RadialParticleAnimation_InterpEaseParticleDistance", funcName )
end

function ThisClass:getInterpEaseParticleDistance()
    return self._interpEaseParticleDistance
end

function ThisClass:getInterpEaseParticleDistanceFunc()
    return self._interpEaseParticleDistanceFunc
end

-- Same as :setInterpEaseOverall(), but for how each particle scales over their lifetime.
function ThisClass:setInterpEaseParticleScale( funcName )
    if funcName == nil then funcName = self.class.INTERP_EASE_PARTICLE_SCALE end
    if funcName == self._interpEaseParticleScale then return end

    self._interpEaseParticleScaleFunc = resolveEaseFuncName( funcName )
    self._interpEaseParticleScale = funcName
    self:syncProperty( "RadialParticleAnimation_InterpEaseParticleScale", funcName )
end

function ThisClass:getInterpEaseParticleScale()
    return self._interpEaseParticleScale
end

function ThisClass:getInterpEaseParticleScaleFunc()
    return self._interpEaseParticleScaleFunc
end

-- Same as :setInterpEaseOverall(), but for how each particle's color changes over their lifetime.
function ThisClass:setInterpEaseParticleColor( funcName )
    if funcName == nil then funcName = self.class.INTERP_EASE_PARTICLE_COLOR end
    if funcName == self._interpEaseParticleColor then return end

    self._interpEaseParticleColorFunc = resolveEaseFuncName( funcName )
    self._interpEaseParticleColor = funcName
    self:syncProperty( "RadialParticleAnimation_InterpEaseParticleColor", funcName )
end

function ThisClass:getInterpEaseParticleColor()
    return self._interpEaseParticleColor
end

function ThisClass:getInterpEaseParticleColorFunc()
    return self._interpEaseParticleColorFunc
end

-- Spawns up to one particle (ignoring active max), returning the associated holo. It is not recommended to call this manually.
function ThisClass:spawnParticle( animTime, interpFracOverall )
    if SERVER then
        net.start( "LKL_RadialParticleAnimation_SpawnParticle" )
        net.writeUInt( self:getID(), 16 )
        net.writeFloat( animTime )
        net.writeFloat( interpFracOverall )
        net.send()

        return
    end

    local inactiveGroup = self:getHoloGroup( "inactive" )
    local inactiveCount = #inactiveGroup
    if inactiveCount == 0 then return false end

    local holo = inactiveGroup[inactiveCount]
    self:changeHoloGroup( holo, "active" )

    local distanceBegin = lerpUnclamped( interpFracOverall, self:getParticleDistanceBeginStart(), self:getParticleDistanceBeginEnd() )
    local distanceBeginVariance = lerpUnclamped( interpFracOverall, self:getParticleDistanceBeginVarianceStart(), self:getParticleDistanceBeginVarianceEnd() )
    local distanceFinish = lerpUnclamped( interpFracOverall, self:getParticleDistanceFinishStart(), self:getParticleDistanceFinishEnd() )
    local lifetime = lerpUnclamped( interpFracOverall, self:getParticleLifetimeStart(), self:getParticleLifetimeEnd() )
    local scaleBegin = lerpUnclamped( interpFracOverall, self:getParticleScaleBeginStart(), self:getParticleScaleBeginEnd() )
    local scaleFinish = lerpUnclamped( interpFracOverall, self:getParticleScaleFinishStart(), self:getParticleScaleFinishEnd() )
    local colorBeginHSV = hsvMath.lerpHSVToHSV( interpFracOverall, self._particleColorBeginStartHSV, self._particleColorBeginEndHSV, false )
    local colorFinishHSV = hsvMath.lerpHSVToHSV( interpFracOverall, self._particleColorFinishStartHSV, self._particleColorFinishEndHSV, false )
    local model = self:getParticleModel()
    local material = self:getParticleMaterial()
    local fullbright = self:getParticleFullbright()
    local follow = self:getParticleFollow()
    local offsetAng = self:getParticleAngle()

    distanceBegin = distanceBegin + mathRand( -distanceBeginVariance, distanceBeginVariance )
    lifetime = mathMax( lifetime, 0.01 )

    local selfPos = self:getPos()
    local dir = vectorMath.randomDirection()
    local _, ang = localToWorld( VECTOR_ZERO, offsetAng, VECTOR_ZERO, ( -dir ):getAngle() )
    local posBegin = selfPos + dir * distanceBegin
    local posBeginLocal
    local angLocal
    local dirLocal

    holo:setModel( model )
    holo:setMaterial( material )
    holo:suppressEngineLighting( fullbright )
    holo:setPos( posBegin )
    holo:setAngles( ang )
    holo:setScale( scaleBegin )
    holo:setColor( hsvMath.hsvToRGB( colorBeginHSV ) )

    if follow then
        local selfAng = self:getAngles()
        posBeginLocal, angLocal = worldToLocal( posBegin, ang, selfPos, selfAng )
        dirLocal = worldToLocal( dir, ANGLE_ZERO, VECTOR_ZERO, selfAng )
    end

    holo._ltRadialParticleAnim_ParticleData = {
        DistanceBegin = distanceBegin,
        DistanceFinish = distanceFinish,
        Lifetime = lifetime,
        ScaleBegin = scaleBegin,
        ScaleFinish = scaleFinish,
        ColorBeginHSV = colorBeginHSV,
        ColorFinishHSV = colorFinishHSV,
        TimeBegin = animTime,
        PosBegin = posBegin,
        Dir = dir,
        Follow = follow,
        PosBeginLocal = posBeginLocal,
        AngLocal = angLocal,
        DirLocal = dirLocal,
    }

    return holo
end

function ThisClass:setParticleActiveMinStart( amount )
    if amount == nil then amount = self.class.PARTICLE_ACTIVE_MIN_START end
    if amount == self._particleActiveMinStart then return end
    if type( amount ) ~= "number" then error( "Expected amount to be a number or nil" ) end
    if math.floor( amount ) ~= amount then error( "Expected amount to be an integer" ) end
    if amount < 0 then error( "Expected amount to be >= 0" ) end

    self._particleActiveMinStart = amount
    self:syncProperty( "RadialParticleAnimation_ParticleActiveMinStart", amount, 10, true )
end

function ThisClass:getParticleActiveMinStart()
    return self._particleActiveMinStart or self.class.PARTICLE_ACTIVE_MIN_START
end

function ThisClass:setParticleActiveMinEnd( amount )
    if amount == nil then amount = self.class.PARTICLE_ACTIVE_MIN_END end
    if amount == self._particleActiveMinEnd then return end
    if type( amount ) ~= "number" then error( "Expected amount to be a number or nil" ) end
    if math.floor( amount ) ~= amount then error( "Expected amount to be an integer" ) end
    if amount < 0 then error( "Expected amount to be >= 0" ) end

    self._particleActiveMinEnd = amount
    self:syncProperty( "RadialParticleAnimation_ParticleActiveMinEnd", amount, 10, true )
end

function ThisClass:getParticleActiveMinEnd()
    return self._particleActiveMinEnd or self.class.PARTICLE_ACTIVE_MIN_END
end

function ThisClass:setParticleActiveMaxStart( amount )
    if amount == nil then amount = self.class.PARTICLE_ACTIVE_MAX_START end
    if amount == self._particleActiveMaxStart then return end
    if type( amount ) ~= "number" then error( "Expected amount to be a number or nil" ) end
    if math.floor( amount ) ~= amount then error( "Expected amount to be an integer" ) end
    if amount < 0 then error( "Expected amount to be >= 0" ) end

    self._particleActiveMaxStart = amount
    self:syncProperty( "RadialParticleAnimation_ParticleActiveMaxStart", amount, 10, true )
end

function ThisClass:getParticleActiveMaxStart()
    return self._particleActiveMaxStart or self.class.PARTICLE_ACTIVE_MAX_START
end

function ThisClass:setParticleActiveMaxEnd( amount )
    if amount == nil then amount = self.class.PARTICLE_ACTIVE_MAX_END end
    if amount == self._particleActiveMaxEnd then return end
    if type( amount ) ~= "number" then error( "Expected amount to be a number or nil" ) end
    if math.floor( amount ) ~= amount then error( "Expected amount to be an integer" ) end
    if amount < 0 then error( "Expected amount to be >= 0" ) end

    self._particleActiveMaxEnd = amount
    self:syncProperty( "RadialParticleAnimation_ParticleActiveMaxEnd", amount, 10, true )
end

function ThisClass:getParticleActiveMaxEnd()
    return self._particleActiveMaxEnd or self.class.PARTICLE_ACTIVE_MAX_END
end

function ThisClass:setParticleActiveChanceStart( chance )
    if chance == nil then chance = self.class.PARTICLE_ACTIVE_CHANCE_START end
    if chance == self._particleActiveChanceStart then return end
    if type( chance ) ~= "number" then error( "Expected chance to be a number or nil" ) end
    if chance < 0 then error( "Expected chance to be >= 0" ) end
    if chance > 1 then error( "Expected chance to be <= 1" ) end

    self._particleActiveChanceStart = chance
    self:syncProperty( "RadialParticleAnimation_ParticleActiveChanceStart", chance, "float", nil )
end

function ThisClass:getParticleActiveChanceStart()
    return self._particleActiveChanceStart or self.class.PARTICLE_ACTIVE_CHANCE_START
end



function ThisClass:setParticleActiveChanceEnd( chance )
    if chance == nil then chance = self.class.PARTICLE_ACTIVE_CHANCE_END end
    if chance == self._particleActiveChanceEnd then return end
    if type( chance ) ~= "number" then error( "Expected chance to be a number or nil" ) end
    if chance < 0 then error( "Expected chance to be >= 0" ) end
    if chance > 1 then error( "Expected chance to be <= 1" ) end

    self._particleActiveChanceEnd = chance
    self:syncProperty( "RadialParticleAnimation_ParticleActiveChanceEnd", chance, "float", nil )
end

function ThisClass:getParticleActiveChanceEnd()
    return self._particleActiveChanceEnd or self.class.PARTICLE_ACTIVE_CHANCE_END
end

function ThisClass:setParticleDistanceBeginStart( distance )
    if distance == nil then distance = self.class.PARTICLE_DISTANCE_BEGIN_START end
    if distance == self._particleDistanceBeginStart then return end
    if type( distance ) ~= "number" then error( "Expected distance to be a number or nil" ) end

    self._particleDistanceBeginStart = distance
    self:syncProperty( "RadialParticleAnimation_ParticleDistanceBeginStart", distance, "float", nil )
end

function ThisClass:getParticleDistanceBeginStart()
    return self._particleDistanceBeginStart or self.class.PARTICLE_DISTANCE_BEGIN_START
end

function ThisClass:setParticleDistanceBeginEnd( distance )
    if distance == nil then distance = self.class.PARTICLE_DISTANCE_BEGIN_END end
    if distance == self._particleDistanceBeginEnd then return end
    if type( distance ) ~= "number" then error( "Expected distance to be a number or nil" ) end

    self._particleDistanceBeginEnd = distance
    self:syncProperty( "RadialParticleAnimation_ParticleDistanceBeginEnd", distance, "float", nil )
end

function ThisClass:getParticleDistanceBeginEnd()
    return self._particleDistanceBeginEnd or self.class.PARTICLE_DISTANCE_BEGIN_END
end

function ThisClass:setParticleDistanceFinishStart( distance )
    if distance == nil then distance = self.class.PARTICLE_DISTANCE_FINISH_START end
    if distance == self._particleDistanceFinishStart then return end
    if type( distance ) ~= "number" then error( "Expected distance to be a number or nil" ) end

    self._particleDistanceFinishStart = distance
    self:syncProperty( "RadialParticleAnimation_ParticleDistanceFinishStart", distance, "float", nil )
end

function ThisClass:getParticleDistanceFinishStart()
    return self._particleDistanceFinishStart or self.class.PARTICLE_DISTANCE_FINISH_START
end

function ThisClass:setParticleDistanceFinishEnd( distance )
    if distance == nil then distance = self.class.PARTICLE_DISTANCE_FINISH_END end
    if distance == self._particleDistanceFinishEnd then return end
    if type( distance ) ~= "number" then error( "Expected distance to be a number or nil" ) end

    self._particleDistanceFinishEnd = distance
    self:syncProperty( "RadialParticleAnimation_ParticleDistanceFinishEnd", distance, "float", nil )
end

function ThisClass:getParticleDistanceFinishEnd()
    return self._particleDistanceFinishEnd or self.class.PARTICLE_DISTANCE_FINISH_END
end

function ThisClass:setParticleDistanceBeginVarianceStart( distance )
    if distance == nil then distance = self.class.PARTICLE_DISTANCE_BEGIN_VARIANCE_START end
    if distance == self._particleDistanceBeginVarianceStart then return end
    if type( distance ) ~= "number" then error( "Expected distance to be a number or nil" ) end

    self._particleDistanceBeginVarianceStart = distance
    self:syncProperty( "RadialParticleAnimation_ParticleDistanceBeginVarianceStart", distance, "float", nil )
end

function ThisClass:getParticleDistanceBeginVarianceStart()
    return self._particleDistanceBeginVarianceStart or self.class.PARTICLE_DISTANCE_BEGIN_VARIANCE_START
end

function ThisClass:setParticleDistanceBeginVarianceEnd( distance )
    if distance == nil then distance = self.class.PARTICLE_DISTANCE_BEGIN_VARIANCE_END end
    if distance == self._particleDistanceBeginVarianceEnd then return end
    if type( distance ) ~= "number" then error( "Expected distance to be a number or nil" ) end

    self._particleDistanceBeginVarianceEnd = distance
    self:syncProperty( "RadialParticleAnimation_ParticleDistanceBeginVarianceEnd", distance, "float", nil )
end

function ThisClass:getParticleDistanceBeginVarianceEnd()
    return self._particleDistanceBeginVarianceEnd or self.class.PARTICLE_DISTANCE_BEGIN_VARIANCE_END
end

function ThisClass:setParticleLifetimeStart( time )
    if time == nil then time = self.class.PARTICLE_LIFETIME_START end
    if time == self._particleLifetimeStart then return end
    if type( time ) ~= "number" then error( "Expected time to be a number or nil" ) end
    if time <= 0 then error( "Expected time to be > 0" ) end

    self._particleLifetimeStart = time
    self:syncProperty( "RadialParticleAnimation_ParticleLifetimeStart", time, "float", nil )
end

function ThisClass:getParticleLifetimeStart()
    return self._particleLifetimeStart or self.class.PARTICLE_LIFETIME_START
end

function ThisClass:setParticleLifetimeEnd( time )
    if time == nil then time = self.class.PARTICLE_LIFETIME_END end
    if time == self._particleLifetimeEnd then return end
    if type( time ) ~= "number" then error( "Expected time to be a number or nil" ) end
    if time <= 0 then error( "Expected time to be > 0" ) end

    self._particleLifetimeEnd = time
    self:syncProperty( "RadialParticleAnimation_ParticleLifetimeEnd", time, "float", nil )
end

function ThisClass:getParticleLifetimeEnd()
    return self._particleLifetimeEnd or self.class.PARTICLE_LIFETIME_END
end

function ThisClass:setParticleScaleBeginStart( scale )
    if scale == nil then scale = self.class.PARTICLE_SCALE_BEGIN_START end
    if scale == self._particleScaleBeginStart then return end
    if type( scale ) ~= "Vector" then error( "Expected scale to be a Vector or nil" ) end

    self._particleScaleBeginStart = scale
    self:syncProperty( "RadialParticleAnimation_ParticleScaleBeginStart", scale, nil, nil )
end

function ThisClass:getParticleScaleBeginStart()
    return self._particleScaleBeginStart or self.class.PARTICLE_SCALE_BEGIN_START
end

function ThisClass:setParticleScaleBeginEnd( scale )
    if scale == nil then scale = self.class.PARTICLE_SCALE_BEGIN_END end
    if scale == self._particleScaleBeginEnd then return end
    if type( scale ) ~= "Vector" then error( "Expected scale to be a Vector or nil" ) end

    self._particleScaleBeginEnd = scale
    self:syncProperty( "RadialParticleAnimation_ParticleScaleBeginEnd", scale, nil, nil )
end

function ThisClass:getParticleScaleBeginEnd()
    return self._particleScaleBeginEnd or self.class.PARTICLE_SCALE_BEGIN_END
end

function ThisClass:setParticleScaleFinishStart( scale )
    if scale == nil then scale = self.class.PARTICLE_SCALE_FINISH_START end
    if scale == self._particleScaleFinishStart then return end
    if type( scale ) ~= "Vector" then error( "Expected scale to be a Vector or nil" ) end

    self._particleScaleFinishStart = scale
    self:syncProperty( "RadialParticleAnimation_ParticleScaleFinishStart", scale, nil, nil )
end

function ThisClass:getParticleScaleFinishStart()
    return self._particleScaleFinishStart or self.class.PARTICLE_SCALE_FINISH_START
end

function ThisClass:setParticleScaleFinishEnd( scale )
    if scale == nil then scale = self.class.PARTICLE_SCALE_FINISH_END end
    if scale == self._particleScaleFinishEnd then return end
    if type( scale ) ~= "Vector" then error( "Expected scale to be a Vector or nil" ) end

    self._particleScaleFinishEnd = scale
    self:syncProperty( "RadialParticleAnimation_ParticleScaleFinishEnd", scale, nil, nil )
end

function ThisClass:getParticleScaleFinishEnd()
    return self._particleScaleFinishEnd or self.class.PARTICLE_SCALE_FINISH_END
end

function ThisClass:setParticleColorBeginStart( color )
    if color == nil then color = self.class.PARTICLE_COLOR_BEGIN_START end
    if color == self._particleColorBeginStart then return end
    if type( color ) ~= "Color" then error( "Expected color to be a Color or nil" ) end

    self._particleColorBeginStart = color
    self._particleColorBeginStartHSV = hsvMath.rgbToHSV( color )
    self:syncProperty( "RadialParticleAnimation_ParticleColorBeginStart", color, nil, nil )
end

function ThisClass:getParticleColorBeginStart()
    return self._particleColorBeginStart or self.class.PARTICLE_COLOR_BEGIN_START
end

function ThisClass:setParticleColorBeginEnd( color )
    if color == nil then color = self.class.PARTICLE_COLOR_BEGIN_END end
    if color == self._particleColorBeginEnd then return end
    if type( color ) ~= "Color" then error( "Expected color to be a Color or nil" ) end

    self._particleColorBeginEnd = color
    self._particleColorBeginEndHSV = hsvMath.rgbToHSV( color )
    self:syncProperty( "RadialParticleAnimation_ParticleColorBeginEnd", color, nil, nil )
end

function ThisClass:getParticleColorBeginEnd()
    return self._particleColorBeginEnd or self.class.PARTICLE_COLOR_BEGIN_END
end

function ThisClass:setParticleColorFinishStart( color )
    if color == nil then color = self.class.PARTICLE_COLOR_FINISH_START end
    if color == self._particleColorFinishStart then return end
    if type( color ) ~= "Color" then error( "Expected color to be a Color or nil" ) end

    self._particleColorFinishStart = color
    self._particleColorFinishStartHSV = hsvMath.rgbToHSV( color )
    self:syncProperty( "RadialParticleAnimation_ParticleColorFinishStart", color, nil, nil )
end

function ThisClass:getParticleColorFinishStart()
    return self._particleColorFinishStart or self.class.PARTICLE_COLOR_FINISH_START
end

function ThisClass:setParticleColorFinishEnd( color )
    if color == nil then color = self.class.PARTICLE_COLOR_FINISH_END end
    if color == self._particleColorFinishEnd then return end
    if type( color ) ~= "Color" then error( "Expected color to be a Color or nil" ) end

    self._particleColorFinishEnd = color
    self._particleColorFinishEndHSV = hsvMath.rgbToHSV( color )
    self:syncProperty( "RadialParticleAnimation_ParticleColorFinishEnd", color, nil, nil )
end

function ThisClass:getParticleColorFinishEnd()
    return self._particleColorFinishEnd or self.class.PARTICLE_COLOR_FINISH_END
end

function ThisClass:setParticleModel( model )
    if model == nil then model = self.class.PARTICLE_MODEL end
    if model == self._particleModel then return end
    if type( model ) ~= "string" then error( "Expected model to be a string or nil" ) end

    self._particleModel = model
    self:syncProperty( "RadialParticleAnimation_ParticleModel", model, nil, nil )
end

function ThisClass:getParticleModel()
    return self._particleModel or self.class.PARTICLE_MODEL
end

function ThisClass:setParticleMaterial( material )
    if material == nil then material = self.class.PARTICLE_MATERIAL end
    if material == self._particleMaterial then return end
    if type( material ) ~= "string" then error( "Expected material to be a string or nil" ) end

    self._particleMaterial = material
    self:syncProperty( "RadialParticleAnimation_ParticleMaterial", material, nil, nil )
end

function ThisClass:getParticleMaterial()
    return self._particleMaterial or self.class.PARTICLE_MATERIAL
end

function ThisClass:setParticleFullbright( state )
    if state == nil then state = self.class.PARTICLE_FULLBRIGHT end
    if state == self._particleFullbright then return end
    if type( state ) ~= "boolean" then error( "Expected state to be a boolean or nil" ) end

    self._particleFullbright = state
    self:syncProperty( "RadialParticleAnimation_ParticleFullbright", state, nil, nil )
end

function ThisClass:getParticleFullbright()
    local state = self._particleFullbright
    if state == nil then return self.class.PARTICLE_FULLBRIGHT end

    return state
end

function ThisClass:setParticleFollow( state )
    if state == nil then state = self.class.PARTICLE_FOLLOW end
    if state == self._particleFollow then return end
    if type( state ) ~= "boolean" then error( "Expected state to be a boolean or nil" ) end

    self._particleFollow = state
    self:syncProperty( "RadialParticleAnimation_ParticleFollow", state, nil, nil )
end

function ThisClass:getParticleFollow()
    local state = self._particleFollow
    if state == nil then return self.class.PARTICLE_FOLLOW end

    return state
end

function ThisClass:setParticleAngle( angle )
    if angle == nil then angle = self.class.PARTICLE_ANGLE end
    if angle == self._particleAngle then return end
    if type( angle ) ~= "Angle" then error( "Expected angle to be a Angle or nil" ) end

    self._particleAngle = angle
    self:syncProperty( "RadialParticleAnimation_ParticleAngle", angle, nil, nil )
end

function ThisClass:getParticleAngle()
    return self._particleAngle or self.class.PARTICLE_ANGLE
end

function ThisClass:setInterpClampOverall( state )
    if state == nil then state = self.class.INTERP_CLAMP_OVERALL end
    if state == self._interpClampOverall then return end
    if type( state ) ~= "boolean" then error( "Expected state to be a boolean or nil" ) end

    self._interpClampOverall = state
    self:syncProperty( "RadialParticleAnimation_InterpClampOverall", state, nil, nil )
end

function ThisClass:getInterpClampOverall()
    local state = self._interpClampOverall
    if state == nil then return self.class.INTERP_CLAMP_OVERALL end

    return state
end

function ThisClass:setInterpClampParticleDistance( state )
    if state == nil then state = self.class.INTERP_CLAMP_PARTICLE_DISTANCE end
    if state == self._interpClampParticleDistance then return end
    if type( state ) ~= "boolean" then error( "Expected state to be a boolean or nil" ) end

    self._interpClampParticleDistance = state
    self:syncProperty( "RadialParticleAnimation_InterpClampParticleDistance", state, nil, nil )
end

function ThisClass:getInterpClampParticleDistance()
    local state = self._interpClampParticleDistance
    if state == nil then return self.class.INTERP_CLAMP_PARTICLE_DISTANCE end

    return state
end

function ThisClass:setInterpClampParticleScale( state )
    if state == nil then state = self.class.INTERP_CLAMP_PARTICLE_SCALE end
    if state == self._interpClampParticleScale then return end
    if type( state ) ~= "boolean" then error( "Expected state to be a boolean or nil" ) end

    self._interpClampParticleScale = state
    self:syncProperty( "RadialParticleAnimation_InterpClampParticleScale", state, nil, nil )
end

function ThisClass:getInterpClampParticleScale()
    local state = self._interpClampParticleScale
    if state == nil then return self.class.INTERP_CLAMP_PARTICLE_SCALE end

    return state
end

function ThisClass:setInterpClampParticleColor( state )
    if state == nil then state = self.class.INTERP_CLAMP_PARTICLE_COLOR end
    if state == self._interpClampParticleColor then return end
    if type( state ) ~= "boolean" then error( "Expected state to be a boolean or nil" ) end

    self._interpClampParticleColor = state
    self:syncProperty( "RadialParticleAnimation_InterpClampParticleColor", state, nil, nil )
end

function ThisClass:getInterpClampParticleColor()
    local state = self._interpClampParticleColor
    if state == nil then return self.class.INTERP_CLAMP_PARTICLE_COLOR end

    return state
end


----- OVERRIDABLE FUNCTIONS -----



----- IMPLEMENTED FUNCTIONS -----

function ThisClass:handlePlayback( time )
    if SERVER then return end
    if not self:areHolosSpawned() then return end

    local timeFracOverall = self:getTimeFractional( time )
    local hasMoved = self._ltRadialParticleAnim_HasMoved
    self._ltRadialParticleAnim_HasMoved = false

    local easeFracOverall = self:getInterpEaseOverallFunc()( timeFracOverall )
    local easeFuncParticleDistance = self:getInterpEaseParticleDistanceFunc()
    local easeFuncParticleScale = self:getInterpEaseParticleScaleFunc()
    local easeFuncParticleColor = self:getInterpEaseParticleColorFunc()
    local interpClampOverall = self:getInterpClampOverall()
    local interpClampParticleDistance = self:getInterpClampParticleDistance()
    local interpClampParticleScale = self:getInterpClampParticleScale()
    local interpClampParticleColor = self:getInterpClampParticleColor()

    local interpFracOverall = interpClampOverall and mathClamp( easeFracOverall, 0, 1 ) or easeFracOverall
    local activeMin = mathFloor( lerpUnclamped( interpFracOverall, self:getParticleActiveMinStart(), self:getParticleActiveMinEnd() ) )
    local activeMax = mathFloor( lerpUnclamped( interpFracOverall, self:getParticleActiveMaxStart(), self:getParticleActiveMaxEnd() ) )
    local activeChance = lerpUnclamped( interpFracOverall, self:getParticleActiveChanceStart(), self:getParticleActiveChanceEnd() )

    activeMax = mathMin( activeMax, self:getParticleLimit() )
    activeMin = mathMin( activeMin, activeMax )

    -- Process active particles
    local activeGroup = self:getHoloGroup( "active" )
    local activeCount = #activeGroup
    local selfPos = self:getPos()
    local selfAng = self:getAngles()

    for i = activeCount, 1, -1 do
        local holo = activeGroup[i]
        local particleData = holo._ltRadialParticleAnim_ParticleData
        local timeFracParticle = ( time - particleData.TimeBegin ) / particleData.Lifetime

        if timeFracParticle > 1 then
            self:changeHoloGroup( holo, "inactive" )

            holo._ltRadialParticleAnim_ParticleData = nil
            holo:setColor( COLOR_EMPTY )
            holo:setPos( VECTOR_ZERO )

            activeCount = activeCount - 1
        else
            local easeFracParticleDistance = easeFuncParticleDistance( timeFracParticle )
            local easeFracParticleScale = easeFuncParticleScale( timeFracParticle )
            local easeFracParticleColor = easeFuncParticleColor( timeFracParticle )

            local interpFracParticleDistance = interpClampParticleDistance and mathClamp( easeFracParticleDistance, 0, 1 ) or easeFracParticleDistance
            local interpFracParticleScale = interpClampParticleScale and mathClamp( easeFracParticleScale, 0, 1 ) or easeFracParticleScale
            local interpFracParticleColor = interpClampParticleColor and mathClamp( easeFracParticleColor, 0, 1 ) or easeFracParticleColor

            local distance = lerpUnclamped( interpFracParticleDistance, particleData.DistanceBegin, particleData.DistanceFinish )
            local scale = lerpUnclamped( interpFracParticleScale, particleData.ScaleBegin, particleData.ScaleFinish )
            local color = hsvMath.lerpHSVToRGB( interpFracParticleColor, particleData.ColorBeginHSV, particleData.ColorFinishHSV, false )
            local follow = particleData.Follow

            holo:setScale( scale )
            holo:setColor( color )

            if follow and hasMoved then
                local posLocal = particleData.PosBeginLocal + particleData.DirLocal * distance
                local angLocal = particleData.AngLocal

                local pos, ang = localToWorld( posLocal, angLocal, selfPos, selfAng )

                holo:setPos( pos )
                holo:setAngles( ang )
            else
                local pos = particleData.PosBegin + particleData.Dir * distance

                holo:setPos( pos )
            end
        end
    end

    -- Create new particles
    while activeCount < activeMin do -- Enforce minimum
        local holo = self:spawnParticle( time, interpFracOverall )
        if not holo then break end

        activeCount = activeCount + 1
    end

    if activeCount < activeMax and mathRand( 0, 1 ) < activeChance then -- Random chance for extra particle
        local holo = self:spawnParticle( time, interpFracOverall )
        if holo then activeCount = activeCount + 1 end
    end
end

function ThisClass:onStopPlaying( isFullStop )
    if SERVER then return end

    if isFullStop then
        self:setAllHolosColor( COLOR_EMPTY )

        local groupActive = self:getHoloGroup( "active" )

        for i = #groupActive, 1, -1 do
            local holo = groupActive[i]

            self:changeHoloGroup( holo, "inactive" )
            holo._ltRadialParticleAnim_ParticleData = nil
        end
    end
end

-- Dissallow infinite-duration animations, since it will break start/end calculations.
function ThisClass:setDuration( duration )
    if duration == 0 then error( "This class does not support infinite-length durations, duration must be > 0" ) end

    ThisClass.super.setDuration( self, duration )
end

function ThisClass:onPosAngChanged( ... )
    self._ltRadialParticleAnim_HasMoved = true

    ThisClass.super.onPosAngChanged( self, ... )
end


----- PRIVATE FUNCTIONS -----

resolveEaseFuncName = function( funcName )
    if type( funcName ) ~= "string" then error( "Expected funcName to be a string" ) end

    local func

    if funcName:sub( 1, 3 ) == "ls:" then
        loadstring( "func = " .. funcName:sub( 4 ) )()
    else
        func = math[funcName]
    end

    if type( func ) ~= "function" then error( "Expected funcName to resolve to a function" ) end

    return func
end

lerpUnclamped = function( frac, from, to )
    if from == to then return from end
    if frac == 1 then return to end
    if frac == 0 then return from end

    return from + ( to - from ) * frac
end


----- SETUP -----

if SERVER then
    function ThisClass:writeCreationData( pos, ang, particleLimit )
        net.writeVector( pos )
        net.writeAngle( ang )
        net.writeUInt( particleLimit, 10 )
    end

    return
end


function ThisClass.static:readCreationData()
    return {
        net.readVector(),
        net.readAngle(),
        net.readUInt( 10 ),
    }
end


net.receive( "LKL_RadialParticleAnimation_SpawnParticle", function()
    local anim = Syncable:readSyncedCopy()
    local animTime = net.readFloat()
    local interpFracOverall = net.readFloat()

    if not anim then return end

    anim:spawnParticle( animTime, interpFracOverall )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpEaseOverall", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readString()

    if not anim then return end

    anim:setInterpEaseOverall( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpEaseParticleDistance", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readString()

    if not anim then return end

    anim:setInterpEaseParticleDistance( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpEaseParticleScale", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readString()

    if not anim then return end

    anim:setInterpEaseParticleScale( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpEaseParticleColor", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readString()

    if not anim then return end

    anim:setInterpEaseParticleColor( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleActiveMinStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readUInt( 10 )
    if not anim then return end

    anim:setParticleActiveMinStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleActiveMinEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readUInt( 10 )
    if not anim then return end

    anim:setParticleActiveMinEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleActiveMaxStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readUInt( 10 )
    if not anim then return end

    anim:setParticleActiveMaxStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleActiveMaxEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readUInt( 10 )
    if not anim then return end

    anim:setParticleActiveMaxEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleActiveChanceStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleActiveChanceStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleActiveChanceEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleActiveChanceEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleDistanceBeginStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleDistanceBeginStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleDistanceBeginEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleDistanceBeginEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleDistanceFinishStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleDistanceFinishStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleDistanceFinishEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleDistanceFinishEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleDistanceBeginVarianceStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleDistanceBeginVarianceStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleDistanceBeginVarianceEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleDistanceBeginVarianceEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleLifetimeStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleLifetimeStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleLifetimeEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readFloat()
    if not anim then return end

    anim:setParticleLifetimeEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleScaleBeginStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readVector()
    if not anim then return end

    anim:setParticleScaleBeginStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleScaleBeginEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readVector()
    if not anim then return end

    anim:setParticleScaleBeginEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleScaleFinishStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readVector()
    if not anim then return end

    anim:setParticleScaleFinishStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleScaleFinishEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readVector()
    if not anim then return end

    anim:setParticleScaleFinishEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleColorBeginStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readColor()
    if not anim then return end

    anim:setParticleColorBeginStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleColorBeginEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readColor()
    if not anim then return end

    anim:setParticleColorBeginEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleColorFinishStart", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readColor()
    if not anim then return end

    anim:setParticleColorFinishStart( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleColorFinishEnd", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readColor()
    if not anim then return end

    anim:setParticleColorFinishEnd( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleModel", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readString()
    if not anim then return end

    anim:setParticleModel( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleMaterial", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readString()
    if not anim then return end

    anim:setParticleMaterial( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleFullbright", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readBool()
    if not anim then return end

    anim:setParticleFullbright( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleFollow", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readBool()
    if not anim then return end

    anim:setParticleFollow( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_ParticleAngle", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readAngle()
    if not anim then return end

    anim:setParticleAngle( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpClampOverall", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readBool()
    if not anim then return end

    anim:setInterpClampOverall( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpClampParticleDistance", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readBool()
    if not anim then return end

    anim:setInterpClampParticleDistance( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpClampParticleScale", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readBool()
    if not anim then return end

    anim:setInterpClampParticleScale( value )
end )

net.receive( "LKL_Syncable_Set__RadialParticleAnimation_InterpClampParticleColor", function()
    local anim = Syncable:readSyncedCopy()
    local value = net.readBool()
    if not anim then return end

    anim:setInterpClampParticleColor( value )
end )
