--@name Spell
--@author legokidlogan
--@shared
--@include lkl/standard_printable.txt

-- Base class for spells, not meant to be used directly.

if Spell then return end

require( "lkl/standard_printable.txt" )

Spell = class( "Spell", StandardPrintable )


local ICON_SIZE = spellbook.ICON_SIZE

local spellsByName = {}
local spellHUDFont = nil
local scrW, scrH
local lastTickTime = timer.curtime()
local simpleMessageEndTime = 0
local simpleMessageStr = false
local simpleMessageColor = false
local iconQueue = {}
local iconRTs = {}
local iconCount = 0
local iconsPerRow = math.floor( 1024 / ICON_SIZE )
local iconsPerRT = iconsPerRow * iconsPerRow
local setParamCameFromOwner = false
local allSpellsLoaded = false
local modelAssociationQueue = {}

local netTypes = {
    boolean = "Bool",
    number = "Float",
    string = "String",
    Vector = "Vector",
    Angle = "Angle",
    Entity = "Entity",
}

local loadNextIcon
local netGenericWrite
local netGenericRead
local processDescription

if CLIENT then
    spellHUDFont = render.createFont( "Default", 48, 400, true, false, false, false, false, false, false )
    scrW, scrH = render.getGameResolution()
end


----- STATIC FUNCTIONS -----

--[[
    params: {
        name = string, -- Spell name. Used to sort the spell order with spellbook.MANUAL_SPELL_ORDER.
        radialName = (optional) string, -- Name to use in the radial menu. Defaults to name, though will not auto-update if it changes.
        description = string, -- Spell description. Can have newlines.
        manaCost = number, -- Mana cost.
        manaCostActive = number, -- Mana cost while active.
        spellCooldown = number, -- Spell cooldown.
        globalCooldown = number, -- Global cooldown.
        cooldownResetsOnRespawn = (optional) boolean, -- Whether to reset the spell cooldown on respawn. Defaults to true.
        color = Color, -- HSV color for the spell. Affects the radial menu and spellbook icon.
        nameColorUnhovered = Color, -- HSVA color for the radial menu spell name when unhovered. Set hue to -1 to copy from color.
        nameColorHovered = Color, -- HSVA color for the radial menu spell name when hovered. Set hue to -1 to copy from color.
        iconURL = (optional) string, -- URL or base64 string for the spell icon. Can be left as an empty string. If non-empty, must match ICON_SIZE x ICON_SIZE.
        iconUseColor = (optional) boolean, -- If true, the icon will be tinted with the spell's color. Default is false.
        rightPageStyle = (optional) string, -- The right page style to use for this spell. Applies only to the owner client.
    }
--]]
function Spell:initialize( params )
    if type( params ) ~= "table" then error( "Expected params to be a table" ) end
    if type( params.name ) ~= "string" then error( "Expected params.name to be a string" ) end
    if params.radialName ~= nil and type( params.radialName ) ~= "string" then error( "Expected params.radialName to be a string or nil" ) end
    if type( params.description ) ~= "string" then error( "Expected params.description to be a string" ) end
    if type( params.manaCost ) ~= "number" then error( "Expected params.manaCost to be a number" ) end
    if type( params.manaCostActive ) ~= "number" then error( "Expected params.manaCostActive to be a number" ) end
    if type( params.spellCooldown ) ~= "number" then error( "Expected params.spellCooldown to be a number" ) end
    if type( params.globalCooldown ) ~= "number" then error( "Expected params.globalCooldown to be a number" ) end
    if params.cooldownResetsOnRespawn ~= nil and type( params.cooldownResetsOnRespawn ) ~= "boolean" then error( "Expected params.cooldownResetsOnRespawn to be a boolean or nil" ) end
    if type( params.color ) ~= "Color" then error( "Expected params.color to be a Color" ) end
    if type( params.nameColorUnhovered ) ~= "Color" then error( "Expected params.nameColorUnhovered to be a Color" ) end
    if type( params.nameColorHovered ) ~= "Color" then error( "Expected params.nameColorHovered to be a Color" ) end
    if params.iconURL ~= nil and type( params.iconURL ) ~= "string" then error( "Expected params.iconURL to be a string or nil" ) end
    if params.iconUseColor ~= nil and type( params.iconUseColor ) ~= "boolean" then error( "Expected params.iconUseColor to be a boolean or nil" ) end
    if params.rightPageStyle ~= nil and type( params.rightPageStyle ) ~= "string" then error( "Expected params.rightPageStyle to be a string or nil" ) end

    if spellsByName[params.name] then error( "Spell with name '" .. params.name .. "' already exists" ) end

    spellsByName[params.name] = self

    local description = processDescription( self, params.description )

    self._name = params.name
    self._radialName = params.radialName or params.name
    self._description = description
    self._descriptionLines = string.split( description, "\n" )
    self._manaCost = params.manaCost
    self._manaCostActive = params.manaCostActive
    self._spellCooldown = params.spellCooldown
    self._globalCooldown = params.globalCooldown
    self._iconUseColor = params.iconUseColor or false

    if params.cooldownResetsOnRespawn == nil then
        self._cooldownResetsOnRespawn = true
    else
        self._cooldownResetsOnRespawn = params.cooldownResetsOnRespawn
    end

    local color = params.color:clone()
    local nameColorUnhovered = params.nameColorUnhovered:clone()
    local nameColorHovered = params.nameColorHovered:clone()
    local iconURL = params.iconURL or ""
    local hasIcon = iconURL ~= ""
    local colorRGB = color:hsvToRGB()
    colorRGB.a = color.a

    if nameColorUnhovered.r == -1 then
        self._nameColorUnhoveredCopiesHue = true
    end

    if nameColorHovered.r == -1 then
        self._nameColorHoveredCopiesHue = true
    end

    self._color = color
    self._colorRGB = colorRGB
    self._nameColorUnhovered = nameColorUnhovered
    self._nameColorHovered = nameColorHovered
    self._hasIcon = false
    self._active = false
    self._modelAssociations = {}
    self._modelAssociationOrder = {}
    self._rightPageStyle = params.rightPageStyle

    if hasIcon and CLIENT then
        table.insert( iconQueue, {
            url = iconURL,
            spell = self,
        } )

        if #iconQueue == 1 then
            loadNextIcon()
        end
    end
end

function Spell.static:getByName( name )
    return spellsByName[name]
end

function Spell.static:getByID( id )
    return spellbook.spells[id]
end


if SERVER or player() == owner() then
    function Spell.static:startSimpleMessage( duration, str, color )
        if CLIENT then
            simpleMessageEndTime = timer.curtime() + duration
            simpleMessageStr = str
            simpleMessageColor = color or Color( 255, 255, 255, 255 )
        else
            net.start( "LKL_Spellbook_Spell_StartSimpleMessage" )
                net.writeFloat( timer.curtime() + duration )
                net.writeString( str )
                net.writeColor( color or Color( 255, 255, 255, 255 ) )
            net.send( owner() )
        end
    end
end


----- INSTANCE FUNCTIONS -----

if SERVER or player() == owner() then
    -- Refunds the mana cost of a spell, without affecting cooldowns.
    -- Useful for when a spell fails due to the prop buffer being empty, cpu quota being too high, etc.
    function Spell:refundManaCost( strength )
        strength = strength or 1

        spellbook.spendMana( -self:getManaCost() * strength )
    end
end


if SERVER then
    -- Updates the associated model count for a specific niceName, and notifies clients.
    function Spell:updateAssociatedModelCount( niceName )
        if not allSpellsLoaded then return end

        local byModel = self._modelAssociations[niceName]
        local oldCount = byModel.__count
        local count = self:getAssociatedModelCount( niceName )
        if count == oldCount then return end

        byModel.__count = count

        local spellID = self:getSpellID()
        local timerName = "LKL_Spellbook_Spell_SafeNet_AssociatedModelCount_" .. spellID .. "_" .. niceName

        local function checkBad()
            return net.getBytesLeft() - 100 < 4 + #niceName
        end

        local function send()
            net.start( "LKL_Spellbook_Spell_SetAssociatedModelCount" )
            net.writeUInt( spellID, 16 )
            net.writeString( niceName )
            net.writeInt( count, 16 )
            net.send()
        end

        if checkBad() then
            timer.create( timerName, 0.05, 1, function()
                if checkBad() then return end

                timer.remove( timerName )
                send()
            end )
        else
            send()
        end

        hook.run( "LKL_Spellbook_Spell_AssociatedModelCountChanged", self:getSpellID(), niceName, oldCount, count )
    end
end


if CLIENT and player() == owner() then
    function Spell:checkCooldowns()
        local now = timer.curtime()

        if spellbook.globalCooldownEndTime > now then return false end
        if ( spellbook.spellCooldownEndTimes[self:getSpellID()] or 0 ) > now then return false end

        return true
    end

    function Spell:playCooldownSound()
        if spellbook.DISABLE_COOLDOWN_SOUND then return end

        local now = timer.curtime()
        if ( self._nextCooldownSoundTime or 0 ) > now then return end

        self._nextCooldownSoundTime = now + 0.5

        pcall( function() -- pcall for emitsound burst limit.
            player():emitSound( "physics/wood/wood_box_impact_bullet1.wav", 75, 85, 0.5 )
            player():emitSound( "physics/wood/wood_solid_impact_bullet4.wav", 75, 100, 0.1 )
        end )
    end

    function Spell:cast( strength )
        strength = strength or 1

        spellbook.setMana( spellbook.mana - self:getManaCost() * strength )
        spellbook.setSpellCooldown( self:getSpellID(), self:getSpellCooldown() )
        spellbook.setGlobalCooldown( self:getGlobalCooldown() )

        local now = timer.curtime()

        net.start( "LKL_Spellbook_CastSpell" )
            net.writeUInt( self:getSpellID(), 16 )
            net.writeFloat( strength )
            net.writeFloat( now )
        net.send()

        self:onCast( strength, now )
    end

    function Spell:fumble( reason, noCooldowns )
        reason = reason or ""

        if not noCooldowns then
            spellbook.setSpellCooldown( self:getSpellID(), self:getSpellCooldown() )
            spellbook.setGlobalCooldown( self:getGlobalCooldown() )
        end

        local now = timer.curtime()

        net.start( "LKL_Spellbook_FumbleSpell" )
            net.writeUInt( self:getSpellID(), 16 )
            net.writeString( reason )
            net.writeFloat( now )
        net.send()

        self:onFumble( reason, now )
    end

    function Spell:drawManaWarning()
        render.setFont( spellHUDFont )

        local x = scrW * 0.5
        local y = scrH * 0.6
        local baseStr = "Not enough mana to cast "
        local name = self:getName()
        local widthBase = render.getTextSize( baseStr )
        local widthName = render.getTextSize( name )
        local w = widthBase + widthName

        render.setRGBA( 150, 0, 50, 255 )
        render.drawSimpleText( x - w / 2, y, baseStr, TEXT_ALIGN.LEFT, TEXT_ALIGN.CENTER )

        render.setColor( self:getColorRGB() )
        render.drawSimpleText( x + w / 2, y, name, TEXT_ALIGN.RIGHT, TEXT_ALIGN.CENTER )
    end

    function Spell:startManaWarning( duration )
        -- Only one at a time.
        for _, spell in ipairs( spellbook.spells ) do
            spell._showManaWarningEndTime = 0
        end

        self._showManaWarningEndTime = timer.curtime() + duration
    end

    function Spell:setRightPageStyle( style )
        if style ~= nil and type( style ) ~= "string" then
            error( "Expected style to be a string or nil" )
        end

        self._rightPageStyle = style
    end

    function Spell:getRightPageStyle()
        return self._rightPageStyle or spellbook.RIGHT_PAGE_STYLE
    end
end


if SERVER or player() == owner() then
    function Spell:setActive( state )
        if self._active == state then return end

        local now = timer.curtime()

        self._active = state

        net.start( "LKL_Spellbook_Spell_SetActive" )
        net.writeUInt( self:getSpellID(), 16 )
        net.writeBool( state )

        if state then
            self._activeStartTime = now
            net.writeFloat( now )
        end

        net.send()

        self:onSetActive( state, now ) -- Most systems (mana usage, radial menu, etc) shouldn't rely on this, this is for start/stop sounds, etc.
    end
end


if CLIENT then
    -- For spells with icons, this won't be true until the icon loads.
    function Spell:hasIcon()
        return self._hasIcon
    end
end


function Spell:getSpellID()
    return self._spellID
end

function Spell:isActive()
    return self._active
end

function Spell:isSelected()
    return spellbook.selectedSpellID == self._spellID
end

function Spell:getActiveStartTime()
    return self._activeStartTime
end

--[[
    - Associates a spell with a prop model, displaying its buffer count at the bottom of the left page.
    - If used, this must be called in all realms, ideally during spell init.
    - Multiple models per niceName are allowed.
    - Multiple unique providers per niceName and model combination are allowed.
    - Note that counts will be driven by the server, so your provider should be server-based as well.

    niceName: (string)
        - The short name to display in the spellbook.
    model: (string)
        - The prop model to associate with.
        - Can technically be any arbitrary non-model string, as long as the provider understands it.
    provider: (any) (must be non-nil on server)
        - The provider of the model.
        - Stricly necessary on server, not needed on client.
        - By default, only the "lkl/prop_buffer" provider is supported.
        - Listen to the LKL_Spellbook_Spell_AssociateModel hook to add support for other providers that need/prefer setup at init.
        - Listen to the LKL_Spellbook_Spell_GetAssociatedModelCount hook for the provider to return its count.
        - Be sure to use spell:updateAssociatedModelCount( niceName ) on the server when the provider's count changes.
--]]
function Spell:associateModel( niceName, model, provider )
    if not self._spellID then
        table.insert( modelAssociationQueue, {
            spell = self,
            niceName = niceName,
            model = model,
            provider = provider,
            stack = debug.traceback(),
        } )

        return
    end

    if type( niceName ) ~= "string" then error( "Expected niceName to be a string" ) end
    if type( model ) ~= "string" then error( "Expected model to be a string" ) end
    if model == "__count" then error( "model can not be '__count'" ) end
    if SERVER and provider == nil then error( "Expected provider to not be nil on server" ) end

    local byNiceName = self._modelAssociations
    local byModel = byNiceName[niceName]

    if not byModel then
        byModel = {}
        byNiceName[niceName] = byModel
        table.insert( self._modelAssociationOrder, niceName )
    end

    local providers = byModel[model]

    if not providers then
        providers = {}
        byModel[model] = providers
    end

    if provider ~= nil then
        if table.hasValue( providers, provider ) then error( "Cannot have two of the same provider for the same niceName, model combo" ) end

        table.insert( providers, provider )
    end

    hook.run( "LKL_Spellbook_Spell_AssociateModel", self:getSpellID(), niceName, model, provider )
end

-- Returns a lookup of niceName -> count. Only returns the latest cached result.
function Spell:getAssociatedModelCounts()
    local countsByNiceName = {}

    for niceName, byModel in pairs( self._modelAssociations ) do
        countsByNiceName[niceName] = byModel.__count or 0
    end

    return countsByNiceName
end

-- Gets (cached if on client) the associated model count for a specific niceName.
function Spell:getAssociatedModelCount( niceName )
    if not allSpellsLoaded then return 0 end

    local byModel = self._modelAssociations[niceName]
    if CLIENT then return byModel.__count or 0 end

    local count = 0
    local spellID = self:getSpellID()

    for model, providers in pairs( byModel ) do
        if model ~= "__count" then
            for _, provider in ipairs( providers ) do
                count = count + ( hook.run( "LKL_Spellbook_Spell_GetAssociatedModelCount", spellID, niceName, model, provider ) or 0 )
            end
        end
    end

    return count
end

-- Sets the spell's name. Will NOT change its order or name in the radial menu. noNet causes the change to not be networked.
function Spell:setName( name, noNet )
    if type( name ) ~= "string" then error( "Expected name to be a string" ) end
    if self._name == name then return end
    if spellsByName[name] then error( "There is already a spell named '" .. name .. "'" ) end

    local oldName = self._name

    if not self:_setParamVar( "name", name, noNet ) then return end

    spellsByName[oldName] = nil
    spellsByName[name] = self

    hook.run( "LKL_Spellbook_Spell_NameChanged", self:getSpellID(), oldName, name )
end

function Spell:getName()
    return self._name
end


-- Sets the radial menu name; doesn't affect order. noNet causes the change to not be networked. Only has an effect if received by the owner's client.
function Spell:setRadialName( radialName, noNet )
    if type( radialName ) ~= "string" then error( "Expected radialName to be a string" ) end

    if not self:_setParamVar( "radialName", radialName, noNet ) then return end

    hook.run( "LKL_Spellbook_Spell_RadialNameChanged", self:getSpellID(), radialName )
end

function Spell:getRadialName()
    return self._radialName
end

-- Sets the description. noNet causes the change to not be networked.
function Spell:setDescription( description, noNet )
    if type( description ) ~= "string" then error( "Expected description to be a string" ) end

    if not self:_setParamVar( "description", description, noNet ) then return end

    description = processDescription( self, description )
    local descriptionLines = string.split( description, "\n" )
    self._descriptionLines = descriptionLines

    hook.run( "LKL_Spellbook_Spell_DescriptionChanged", self:getSpellID(), description, descriptionLines )
end

function Spell:getDescription()
    return self._description
end

function Spell:getDescriptionLines()
    return self._descriptionLines
end

-- Sets the mana cost. noNet causes the change to not be networked. Note that the client owner is what handles mana, cooldowns, etc.
function Spell:setManaCost( manaCost, noNet )
    if type( manaCost ) ~= "number" then error( "Expected manaCost to be a number" ) end

    self:_setParamVar( "manaCost", manaCost, noNet )
end

function Spell:getManaCost()
    return self._manaCost
end

-- Sets the active mana cost. noNet causes the change to not be networked. Note that the client owner is what handles mana, cooldowns, etc.
function Spell:setManaCostActive( manaCostActive, noNet )
    if type( manaCostActive ) ~= "number" then error( "Expected manaCostActive to be a number" ) end

    self:_setParamVar( "manaCostActive", manaCostActive, noNet )
end

function Spell:getManaCostActive()
    return self._manaCostActive
end

-- Sets the spell cooldown duration. Does NOT affect currently-existing cooldowns. noNet causes the change to not be networked.
function Spell:setSpellCooldown( spellCooldown, noNet )
    if type( spellCooldown ) ~= "number" then error( "Expected spellCooldown to be a number" ) end

    self:_setParamVar( "spellCooldown", spellCooldown, noNet )
end

function Spell:getSpellCooldown()
    return self._spellCooldown
end

-- Sets the global cooldown duration. Does NOT affect currently-existing cooldowns. noNet causes the change to not be networked.
function Spell:setGlobalCooldown( globalCooldown, noNet )
    if type( globalCooldown ) ~= "number" then error( "Expected globalCooldown to be a number" ) end

    self:_setParamVar( "globalCooldown", globalCooldown, noNet )
end

function Spell:getGlobalCooldown()
    return self._globalCooldown
end

-- Sets whether the spell cooldown resets on respawn. noNet causes the change to not be networked.
function Spell:setCooldownResetsOnDeath( resetsOnDeath, noNet )
    if type( resetsOnDeath ) ~= "boolean" then error( "Expected resetsOnDeath to be a boolean" ) end

    self:_setParamVar( "cooldownResetsOnRespawn", resetsOnDeath, noNet )
end

function Spell:doesCooldownResetOnDeath()
    return self._cooldownResetsOnRespawn
end

-- Sets the color in HSV. noNet causes the change to not be networked.
function Spell:setColor( color, noNet )
    if type( color ) ~= "Color" then error( "Expected color to be a Color" ) end

    color = color:clone()

    if not self:_setParamVar( "color", color, noNet ) then return end

    local colorRGB = color:hsvToRGB()
    colorRGB.a = color.a
    self._colorRGB = colorRGB

    hook.run( "LKL_Spellbook_Spell_ColorChanged", self:getSpellID(), color, colorRGB )

    -- Update name colors if they use the spell's hue.
    if self:doesNameColorUnhoveredCopyHue() then
        hook.run( "LKL_Spellbook_Spell_NameColorUnhoveredChanged", self:getSpellID(), self:getNameColorUnhovered() )
    end

    if self:doesNameColorHoveredCopyHue() then
        hook.run( "LKL_Spellbook_Spell_NameColorHoveredChanged", self:getSpellID(), self:getNameColorHovered() )
    end
end

function Spell:getColor()
    return self._color
end

function Spell:getColorRGB()
    return self._colorRGB
end

-- Sets the unhovered name color in HSV. noNet causes the change to not be networked.
function Spell:setNameColorUnhovered( nameColorUnhovered, noNet )
    if type( nameColorUnhovered ) ~= "Color" then error( "Expected nameColorUnhovered to be a Color" ) end

    nameColorUnhovered = nameColorUnhovered:clone()
    self._nameColorUnhoveredCopiesHue = nameColorUnhovered.r == -1

    if not self:_setParamVar( "nameColorUnhovered", nameColorUnhovered, noNet ) then return end

    hook.run( "LKL_Spellbook_Spell_NameColorUnhoveredChanged", self:getSpellID(), self:getNameColorUnhovered() )
end

-- Returns by reference. Do not modify the color directly.
function Spell:getNameColorUnhovered()
    local color = self._nameColorUnhovered

    if self:doesNameColorUnhoveredCopyHue() then
        color = color:clone()
        color.r = self._color.r
    end

    return color
end

function Spell:doesNameColorUnhoveredCopyHue()
    return self._nameColorUnhoveredCopiesHue
end

-- Sets the hovered name color in HSV. noNet causes the change to not be networked.
function Spell:setNameColorHovered( nameColorHovered, noNet )
    if type( nameColorHovered ) ~= "Color" then error( "Expected nameColorHovered to be a Color" ) end

    nameColorHovered = nameColorHovered:clone()
    self._nameColorHoveredCopiesHue = nameColorHovered.r == -1

    if not self:_setParamVar( "nameColorHovered", nameColorHovered, noNet ) then return end

    hook.run( "LKL_Spellbook_Spell_NameColorHoveredChanged", self:getSpellID(), self:getNameColorHovered() )
end

-- Returns by reference. Do not modify the color directly.
function Spell:getNameColorHovered()
    local color = self._nameColorHovered

    if self:doesNameColorHoveredCopyHue() then
        color = color:clone()
        color.r = self._color.r
    end

    return color
end

function Spell:doesNameColorHoveredCopyHue()
    return self._nameColorHoveredCopiesHue
end


----- OVERRIDABLE FUNCTIONS -----

if CLIENT and player() == owner() then
    -- Draws on the owner's HUD unconditionally.
    function Spell:paint()
        local showManaWarningEndTime = self._showManaWarningEndTime or 0

        if showManaWarningEndTime > timer.curtime() then
            self:drawManaWarning()
        end
    end

    function Spell:paintRightPage( _rightPageInfo )
        -- Draws on the right page if this spell is selected and the spellbook is open.
        -- rightPageInfo is a read-only table with useful info for drawing on the right page. See spellbook_right_page_info.txt for details.
    end

    function Spell:onBookClosed()
        -- Called when the book is forcibly desummoned/closed while this spell is selected.
    end
end


function Spell:onKeyPress( _key )
    -- Called in server and owner client realms.
    -- Won't be called unless the spellbook is summoned, open, and this spell is selected.
end

function Spell:onKeyRelease( _key )
    -- Called in server and owner client realms.
end

function Spell:onCast( _strength, _castTime )
    -- Called in all realms.
end

function Spell:onFumble( _reason, _fumbleTime )
    --[[
        - Called in all realms.
        - Not normally called for casts blocked by cooldowns.
        - Built-in reasons:
            - "Mana" - Not enough mana to cast the spell.
            - "ChargeThreshold" - Wasn't charged for long enough.
    --]]
end

function Spell:onSetActive( _state, _startTime )
    -- Called in all realms.
end

function Spell:onManaEmpty()
    -- Called when an active wpell is forcefully stopped due to running out of mana.
end

function Spell:think( _dt )
    -- Called in all realms.
end


----- IMPLEMENTED FUNCTIONS -----

function Spell:tostringInner()
    return self._name
end


----- PRIVATE FUNCTIONS -----

if CLIENT then
    local iconMat = render.createMaterial( "UnlitGeneric" )
    iconMat:setInt( "$flags", 32768 + 2097152 + 16 + 32 )


    loadNextIcon = function()
        local iconInfo = iconQueue[1]
        if not iconInfo then return end

        local url = iconInfo.url
        local spell = iconInfo.spell
        local loaded = false
        local wh = nil

        hook.add( "renderoffscreen", "LKL_Spellbook_Spell_StoreIcon", function()
            if not loaded then return end

            if iconCount % iconsPerRT == 0 then
                local rtCount = #iconRTs + 1
                local rtName = "lkl_spellbook_icon_" .. rtCount

                render.createRenderTarget( rtName )
                iconRTs[rtCount] = rtName
            end

            iconCount = iconCount + 1

            local rtName = iconRTs[#iconRTs]
            local iconPageInd = iconCount % iconsPerRT
            local x = ( ( iconPageInd - 1 ) % iconsPerRow ) * ICON_SIZE
            local y = math.floor( ( ( iconPageInd == 0 and iconsPerRT or iconPageInd ) - 1 ) / iconsPerRow ) * ICON_SIZE

            render.selectRenderTarget( rtName )

            if iconPageInd == 1 then
                render.clearRGBA( 0, 0, 0, 0 )
            end

            render.setRGBA( 255, 255, 255, 255 )
            render.setMaterial( iconMat )
            render.drawTexturedRectUV( x, y, ICON_SIZE, ICON_SIZE, 0, 0, wh / 1024, wh / 1024 )
            render.selectRenderTarget()

            spell._hasIcon = true
            spell._iconRT = rtName
            spell._iconU0 = x / 1024
            spell._iconV0 = y / 1024
            spell._iconU1 = ( x + ICON_SIZE ) / 1024
            spell._iconV1 = ( y + ICON_SIZE ) / 1024

            table.remove( iconQueue, 1 )
            hook.remove( "renderoffscreen", "LKL_Spellbook_Spell_StoreIcon" )
            hook.run( "LKL_Spellbook_Spell_IconLoaded", spell:getSpellID() )
            loadNextIcon()
        end )

        local success = pcall( function()
            iconMat:setTextureURL(
                "$basetexture",
                url,
                function( _, _, w, h )
                    if not w then
                        -- Failed to load the icon.
                        table.remove( iconQueue, 1 )
                        hook.remove( "renderoffscreen", "LKL_Spellbook_Spell_StoreIcon" )
                        loadNextIcon()
                        return
                    end

                    wh = math.max( w, h )
                end,
                function()
                    if not wh then return end

                    loaded = true
                end
            )
        end )

        if not success then
            -- Insufficient permissions or base64 was too large.
            table.remove( iconQueue, 1 )
            hook.remove( "renderoffscreen", "LKL_Spellbook_Spell_StoreIcon" )
            loadNextIcon()
        end
    end
end


netGenericWrite = function( val )
    --net["write" .. netTypes[type( val )]]( val, 16 )

    local typeStr = type( val )

    -- Spellbook colors use HSV, which are floats, so Colors need to be networked manually, as they normally use uints.
    if typeStr == "Color" then
        net.writeFloat( val.r )
        net.writeFloat( val.g )
        net.writeFloat( val.b )
    else
        net["write" .. netTypes[typeStr]]( val, 16 )
    end
end

netGenericRead = function( typeStr )
    --return net["read" .. netTypes[typeStr]]( 16 )

    if typeStr == "Color" then
        local r = net.readFloat()
        local g = net.readFloat()
        local b = net.readFloat()

        return Color( r, g, b )
    end

    return net["read" .. netTypes[typeStr]]( 16 )
end

processDescription = function( spell, description )
    description = string.trim( description )
    local classNameNice = string.gsub( spell.class.name, "([a-z])([A-Z])", "%1 %2" ) -- Add spaces between PascalCase words.
    description = "(" .. classNameNice .. ")\n" .. description

    return description
end


-- Internal function, do not use!
function Spell:_setParamVar( name, val, noNet )
    local privateName = "_" .. name
    local sendAll = CLIENT or not setParamCameFromOwner
    setParamCameFromOwner = false

    if self[privateName] == val then return false end

    self[privateName] = val

    if noNet or ( CLIENT and player() ~= owner() ) then return true end

    net.start( "LKL_Spellbook_Spell_SetParam" )
    net.writeUInt( self:getSpellID(), 16 )
    net.writeString( name )
    netGenericWrite( val )
    net.send( spellbook.getEveryoneButOwner( sendAll ) )

    return true
end


----- SETUP -----

hook.add( "LKL_Spellbook_AllSpellsLoaded", "LKL_Spellbook_Spell_Setup", function()
    allSpellsLoaded = true

    timer.simple( 1, function()
        for i = 1, #modelAssociationQueue do
            local info = modelAssociationQueue[i]
            local spell = info.spell
            local niceName = info.niceName
            local model = info.model
            local provider = info.provider

            local success, err = pcall( function()
                spell:associateModel( niceName, model, provider )
            end )

            if not success then
                print( "Failed to associate model with spell '" .. spell:getName() .. ":\n" .. err .. "\n" .. info.stack )
            end

            modelAssociationQueue[i] = nil -- Clean up memory

            if SERVER then
                spell:updateAssociatedModelCount( niceName )
            end
        end

        if CLIENT then
            net.start( "LKL_Spellbook_Spell_RequestAssociatedModelCounts" )
            net.send()
        end
    end )
end )

hook.add( "tick", "LKL_Spellbook_Spell_ActiveThink", function()
    local now = timer.curtime()
    local dt = now - lastTickTime
    lastTickTime = now

    for _, spell in ipairs( spellbook.spells ) do
        if spell:isActive() then
            if CLIENT and player() == owner() then
                local manaWhenUsed = spellbook.mana - spell:getManaCostActive() * dt

                if manaWhenUsed > 0 then
                    spellbook.mana = manaWhenUsed
                    spell:think( dt )
                else
                    spellbook.mana = 0
                    spell:setActive( false )
                    spell:onManaEmpty()

                    net.start( "LKL_Spellbook_Spell_OnManaEmpty" )
                        net.writeUInt( spell:getSpellID(), 16 )
                        net.writeFloat( now )
                    net.send()
                end
            else
                spell:think( dt )
            end
        else
            spell:think( dt )
        end
    end
end )


if SERVER then
    local propBufferAssociations = {}


    local function updateFromPropBuffer( ent )
        local model = ent:getModel()
        local bySpellID = propBufferAssociations[model]
        if not bySpellID then return end

        for spellID, niceNames in pairs( bySpellID ) do
            local spell = Spell:getByID( spellID )

            for _, niceName in ipairs( niceNames ) do
                spell:updateAssociatedModelCount( niceName )
            end
        end
    end


    hook.add( "LKL_Spellbook_Spell_AssociateModel", "LKL_Spellbook_Spell_SupportLKLPropBuffer", function( spellID, niceName, model, provider )
        if provider ~= "lkl/prop_buffer" then return end

        local bySpellID = propBufferAssociations[model]

        if not bySpellID then
            bySpellID = {}
            propBufferAssociations[model] = bySpellID
        end

        local niceNames = bySpellID[spellID]

        if not niceNames then
            niceNames = {}
            bySpellID[spellID] = niceNames
        end

        table.insert( niceNames, niceName )
    end )

    hook.add( "LKL_Spellbook_Spell_GetAssociatedModelCount", "LKL_Spellbook_Spell_SupportLKLPropBuffer", function( _spellID, _niceName, model, provider )
        if provider ~= "lkl/prop_buffer" then return end

        return propBuffer.getReadyCount( model ) or 0
    end )

    hook.add( "LKL_PropBuffer_PropCreated", "LKL_Spellbook_Spell_SupportLKLPropBuffer", updateFromPropBuffer )
    hook.add( "LKL_PropBuffer_PropStored", "LKL_Spellbook_Spell_SupportLKLPropBuffer", updateFromPropBuffer )
    hook.add( "LKL_PropBuffer_PropTaken", "LKL_Spellbook_Spell_SupportLKLPropBuffer", updateFromPropBuffer )


    net.receive( "LKL_Spellbook_Spell_RequestAssociatedModelCounts", function( _, ply )
        if not allSpellsLoaded then return end

        local bySpellID = {}
        local bytesNeeded = 2

        for spellID, spell in ipairs( spellbook.spells ) do
            local countsByNiceName = spell:getAssociatedModelCounts()
            local niceNameCount = table.count( countsByNiceName )

            if niceNameCount > 0 then
                bySpellID[spellID] = countsByNiceName
                bytesNeeded = bytesNeeded + 4

                for niceName in pairs( countsByNiceName ) do
                    bytesNeeded = bytesNeeded + #niceName + 2
                end
            end
        end

        local timerName = "LKL_Spellbook_Spell_SafeNet_SetAssociatedModelCounts_" .. ply:getSteamID()

        local function checkBad()
            return net.getBytesLeft() - 100 < bytesNeeded
        end

        local function send()
            net.start( "LKL_Spellbook_Spell_SetAssociatedModelCounts" )
            net.writeUInt( table.count( bySpellID ), 16 )

            for spellID, countsByNiceName in pairs( bySpellID ) do
                net.writeUInt( spellID, 16 )
                net.writeUInt( table.count( countsByNiceName ), 16 )

                for niceName, count in pairs( countsByNiceName ) do
                    net.writeString( niceName )
                    net.writeInt( count, 16 )
                end
            end

            net.send( ply )
        end

        if checkBad() then
            timer.create( timerName, 0.05, 1, function()
                if checkBad() then return end

                timer.remove( timerName )
                send()
            end )
        else
            send()
        end
    end )
end


if CLIENT and player() == owner() then
    hook.add( "drawhud", "LKL_Spellbook_Spell_DrawSimpleMessage", function()
        if simpleMessageEndTime < timer.curtime() then return end

        render.setFont( spellHUDFont )
        render.setColor( simpleMessageColor )
        render.drawSimpleText( scrW * 0.5, scrH * 0.55, simpleMessageStr, TEXT_ALIGN.CENTER, TEXT_ALIGN.CENTER )
    end )


    net.receive( "LKL_Spellbook_Spell_StartSimpleMessage", function()
        local endTime = net.readFloat()
        local str = net.readString()
        local color = net.readColor()

        simpleMessageEndTime = endTime
        simpleMessageStr = str
        simpleMessageColor = color
    end )
end


if CLIENT then
    net.receive( "LKL_Spellbook_Spell_SetAssociatedModelCount", function()
        local spellID = net.readUInt( 16 )
        local niceName = net.readString()
        local count = net.readInt( 16 )

        local spell = Spell:getByID( spellID )
        local byModel = spell._modelAssociations[niceName]
        if not byModel then return end

        local oldCount = byModel.__count
        byModel.__count = count

        if oldCount == count then return end

        hook.run( "LKL_Spellbook_Spell_AssociatedModelCountChanged", spellID, niceName, oldCount or 0, count )
    end )

    net.receive( "LKL_Spellbook_Spell_SetAssociatedModelCounts", function()
        local spellCount = net.readUInt( 16 )

        for _ = 1, spellCount do
            local spellID = net.readUInt( 16 )
            local niceNameCount = net.readUInt( 16 )
            local spell = Spell:getByID( spellID )
            local byNiceName = spell._modelAssociations

            for _ = 1, niceNameCount do
                local niceName = net.readString()
                local count = net.readInt( 16 )
                local byModel = byNiceName[niceName]
                if not byModel then continue end

                local oldCount = byModel.__count
                byModel.__count = count

                if oldCount == count then continue end

                hook.run( "LKL_Spellbook_Spell_AssociatedModelCountChanged", spellID, niceName, oldCount or 0, count )
            end
        end
    end )
end


net.receive( "LKL_Spellbook_Spell_SetActive", function( _, ply )
    if SERVER and ply ~= owner() then return end

    local spellID = net.readUInt( 16 )
    local spell = Spell:getByID( spellID )
    local state = net.readBool()
    local startTime

    if state then
        startTime = net.readFloat()
    end

    spell._active = state
    spell._activeStartTime = startTime

    spell:onSetActive( state, startTime )

    if CLIENT then return end

    net.start( "LKL_Spellbook_Spell_SetActive" )
        net.writeUInt( spellID, 16 )
        net.writeBool( state )

        if state then
            net.writeFloat( startTime )
        end
    net.send( spellbook.getEveryoneButOwner() )
end )

net.receive( "LKL_Spellbook_CastSpell", function( _, ply )
    if SERVER and ply ~= owner() then return end

    local spellID = net.readUInt( 16 )
    local spell = Spell:getByID( spellID )
    local strength = net.readFloat()
    local castTime = net.readFloat()

    spell:onCast( strength, castTime )

    if CLIENT then return end

    net.start( "LKL_Spellbook_CastSpell" )
        net.writeUInt( spellID, 16 )
        net.writeFloat( strength )
        net.writeFloat( castTime )
    net.send( spellbook.getEveryoneButOwner() )
end )

net.receive( "LKL_Spellbook_FumbleSpell", function( _, ply )
    if SERVER and ply ~= owner() then return end

    local spellID = net.readUInt( 16 )
    local spell = Spell:getByID( spellID )
    local reason = net.readString()
    local fumbleTime = net.readFloat()

    spell:onFumble( reason, fumbleTime )

    if CLIENT then return end

    net.start( "LKL_Spellbook_FumbleSpell" )
        net.writeUInt( spellID, 16 )
        net.writeString( reason )
        net.writeFloat( fumbleTime )
    net.send( spellbook.getEveryoneButOwner() )
end )

net.receive( "LKL_Spellbook_Spell_OnManaEmpty", function( _, ply )
    if SERVER and ply ~= owner() then return end

    local spellID = net.readUInt( 16 )
    local spell = Spell:getByID( spellID )
    local castTime = net.readFloat()

    spell:onManaEmpty()

    if CLIENT then return end

    net.start( "LKL_Spellbook_Spell_OnManaEmpty" )
        net.writeUInt( spellID, 16 )
        net.writeFloat( castTime )
    net.send( spellbook.getEveryoneButOwner() )
end )

net.receive( "LKL_Spellbook_Spell_SetParam", function( _, ply )
    if SERVER and ply ~= owner() then return end

    local spellID = net.readUInt( 16 )
    local spell = Spell:getByID( spellID )
    local name = net.readString()
    local privateName = "_" .. name
    local upperName = string.upper( string.sub( name, 1, 1 ) ) .. string.sub( name, 2 )
    local val = netGenericRead( type( spell[privateName] ) )

    if SERVER then
        setParamCameFromOwner = true
    end

    spell["set" .. upperName]( spell, val, CLIENT )
    setParamCameFromOwner = false -- In something returns early.
end )
