--@name IK
--@author legokidlogan
--@shared

-- Inverse Kinematics library

libIK = libIK or {}
if libIK._alreadyLoaded then return end
libIK._alreadyLoaded = true


local VECTOR_ZERO = Vector( 0, 0, 0 )
local ANGLE_ZERO = Angle( 0, 0, 0 )

local mSqrt = math.sqrt
local mCos = math.cos
local mASin = math.asin
local mAbs = math.abs

local getOBBSize
local getIKOffset
local sanitizeIK
local getIKBendFromTilt
local determineSegmentEntPosAng


----- SEGMENT SETUP -----

--[[
    - Generate a segment for use with 'ByTilt' IK functions.
    - This is not needed to use the core IK functions, but will generally improve results when working with entities and makes things easier.

    segmentData: (table)
        {
            Ent = ENTITY,                                  --                  -- The entity representing the segment.
            Parent = ENTITY,                               --                  -- The parent entity of the segment.

            OriginOffset = VECTOR (optional),              -- default:  0,0,0  -- The local position of the segment's origin.
            OriginOffsetScaled = VECTOR (optional),        -- default: -1,0,0  -- The local position of the segment's origin, will be scaled by obbSize() / 2.
            OriginOffsetFromParent = VECTOR or nil,        -- default:  nil    -- Creates a local offset from the parent, before adding the above two offsets in space local to the segment.
            OriginOffsetFromParentScaled = VECTOR or nil,  -- default:  nil    -- Same as above, but scaled by the parent.

            EndOffset = VECTOR (optional),                 -- default:  0,0,0  -- The local position of the segment's end.
            EndOffsetScaled = VECTOR (optional),           -- default:  1,0,0  -- The local position of the segment's end, will be scaled by obbSize() / 2.
            EndOffsetFromParent = VECTOR or nil,           -- default:  nil    -- Creates a local offset from the parent, before adding the above two offsets in space local to the segment.
            EndOffsetScaledFromParent = VECTOR or nil,     -- default:  nil    -- Same as above, but scaled by the parent.

            UpDir = VECTOR (optional),                     -- default:  0,1,0  -- The local up direction of the segment. (top of the thigh, top of the calf, back of the arm, etc.)
        }
        - Note that the '____OffsetFromParent' options will fundamentally change how offsets are calculated, use with caution.
            - The resulting offset will vary depending on how the semgent and its parent are located relative to each other when this gets called.
            - An example usecase for this would be if your segment entities are small cubes separated by large, possibly variable, gaps.
            - The regular offset options are in coords local to the segment entity, while the 'FromParent' options are in coords local to the parent entity.
--]]
function libIK.generateSegment( segmentData )
    local segmentEnt = segmentData.Ent
    if not isValid( segmentEnt ) then error( "Expected segmentData.Ent to be valid" ) end

    local parentEnt = segmentData.Parent
    if not isValid( parentEnt ) then error( "Expected segmentData.Parent to be valid" ) end

    local originOffset = getIKOffset(
        segmentEnt, parentEnt,
        segmentData.OriginOffset or Vector( 0, 0, 0 ), segmentData.OriginOffsetScaled or Vector( -1, 0, 0 ),
        segmentData.OriginOffsetFromParent, segmentData.OriginOffsetFromParentScaled
    )

    local endOffset = getIKOffset(
        segmentEnt, parentEnt,
        segmentData.EndOffset or Vector( 0, 0, 0 ), segmentData.EndOffsetScaled or Vector( 1, 0, 0 ),
        segmentData.EndOffsetFromParent, segmentData.EndOffsetScaledFromParent
    )

    local originToEnd = endOffset - originOffset
    local length = originToEnd:getLength()
    if length == 0 then error( "Segments cannot have a length of zero" ) end

    local forwardDir = originToEnd / length
    local upDir = segmentData.UpDir or Vector( 0, 1, 0 )
    local originToEntPos, originToEntAng = worldToLocal( VECTOR_ZERO, ANGLE_ZERO, originOffset, forwardDir:getAngleEx( upDir ) )

    return {
        _ent = segmentEnt,
        _parentEnt = parentEnt,
        _length = length,
        _parentToOrigin = parentEnt:worldToLocal( segmentEnt:localToWorld( originOffset ) ),
        _parentToUpDir = parentEnt:worldToLocalVector( segmentEnt:localToWorldVector( upDir ) ),
        _parentToForwardDir = parentEnt:worldToLocalVector( segmentEnt:localToWorldVector( forwardDir ) ),
        _originToEntPos = originToEntPos,
        _originToEntAng = originToEntAng,
        _endOffset = endOffset,
    }
end

-- Generate multiple segments at once. Doesn't need to be a sequential table.
function libIK.generateSegments( segmentDatas )
    local segments = {}

    for k, segmentData in pairs( segmentDatas ) do
        segments[k] = libIK.generateSegment( segmentData )
    end

    return segments
end


----- SEGMENT HELPERS -----

function libIK.getSegmentEnt( segment )
    return segment._ent
end

function libIK.getSegmentParentEnt( segment )
    return segment._parentEnt
end

function libIK.getSegmentLength( segment )
    return segment._length
end

-- Gets the current world position of the segment's origin.
function libIK.getSegmentOrigin( segment )
    return segment._parentEnt:localToWorld( segment._parentToOrigin )
end

-- Gets the current world position of the segment's end.
function libIK.getSegmentEnd( segment )
    return segment._ent:localToWorld( segment._endOffset )
end

-- For a desired origin position and angle of a segment, returns the position and angle that you will need to set onto the entity.
function libIK.convertSegmentPosAngToEntPosAng( segment, originPos, ang )
    return localToWorld( segment._originToEntPos, segment._originToEntAng, originPos, ang )
end


----- IK FUNCTIONS -----

--[[
    - Calculate the bendPos (elbow, knee, etc.) for a two-segment limb.

    startPos: (Vector)
        - The start position of the limb.
    endPos: (Vector)
        - The target end position of the limb.
    LA: (number)
        - The length of the first segment.
    LB: (number)
        - The length of the second segment.
    bendDir: (Vector) (optional)
        - The direction to bend in, perpendicular to lineDir.
        - If not provided, it will be auto-calculated but could yield unnatural results.
    lineDir: (Vector) (optional)
        - Equal to ( endPos - startPos ):getNormalized().
        - Only provide this if you have the value already, to reduce redundant calculations.
    L: (number) (optional)
        - Equal to ( endPos - startPos ):getLength().
        - Only provide this if you have the value already, to reduce redundant calculations.
    
    RETURNS: bendPos
        bendPos: (Vector or nil)
            - The position of the bend in the limb.
            - May be nil if the segments have different lengths and startPos is too close to endPos.
--]]
function libIK.twoSeg( startPos, endPos, LA, LB, bendDir, lineDir, L )
    endPos, bendDir, lineDir, L = sanitizeIK( startPos, endPos, LA, LB, bendDir, lineDir, L )

    local semiPerim = ( LA + LB + L ) / 2
    local boundingArea = 2 * mSqrt( mAbs( semiPerim * ( semiPerim - LA ) * ( semiPerim - LB ) * ( semiPerim - L ) ) )
    local LBend = boundingArea / L

    local thetaA = mASin( LBend / LA )
    if thetaA ~= thetaA then return end -- NaN check, happens if the segments are different length and startPos is too close to endPos.

    local LAProj = mCos( thetaA ) * LA

    local raiseFrom = startPos + lineDir * LAProj
    local bendPos = raiseFrom + bendDir * LBend

    return bendPos
end

--[[
    - Similar to libIK.twoSeg(), but calculates bendPos1 and bendPos2 for a three-segment limb.
    - Internally performs two-segment IK between segment A and a fake segment X, then again between bendPos1 and endPos with segments B and C.
    - Required args: startPos, endPos, LA, LB, LC, LX
    - Recommended args: bendDir1, bendDir2
    - Optional args: lineDir, L
--]]
function libIK.threeSeg( startPos, endPos, LA, LB, LC, LX, bendDir1, bendDir2, lineDir, L )
    local _
    _, bendDir1, lineDir, L = sanitizeIK( startPos, endPos, LA, LX, bendDir1, lineDir, L )

    local bendPos1 = libIK.twoSeg( startPos, endPos, LA, LX, bendDir1, lineDir, L )
    if not bendPos1 then return end
    local bendPos2 = libIK.twoSeg( bendPos1, endPos, LB, LC, bendDir2 )

    return bendPos1, bendPos2
end

--[[
    - Similar to libIK.threeSeg(), but calculates bendPos1, bendPos2, and bendPos3 for a four-segment limb.
    - Required args: startPos, endPos, LA, LB, LC, LD, LX1, LX2
    - Recommended args: bendDir1, bendDir2, bendDir3
    - Optional args: lineDir, L
--]]
function libIK.fourSeg( startPos, endPos, LA, LB, LC, LD, LX1, LX2, bendDir1, bendDir2, bendDir3, lineDir, L )
    local _
    _, bendDir1, lineDir, L = sanitizeIK( startPos, endPos, LA, LX1, bendDir1, lineDir, L )

    local bendPos1 = libIK.twoSeg( startPos, endPos, LA, LX1, bendDir1, lineDir, L )
    if not bendPos1 then return end
    local bendPos2, bendPos3 = libIK.threeSeg( bendPos1, endPos, LB, LC, LD, LX2, bendDir2, bendDir3 )

    return bendPos1, bendPos2, bendPos3
end


----- IK BY TILT FUNCTIONS -----

--[[
    - Similar to libIK.twoSeg(), but uses segment data which allows for more realistic IK and easer end-user implementation.

    segmentA: (table)
        - The first segment.
        - Should be generated with libIK.generateSegment().
    segmentB: (table)
        - The second segment.
        - Should be generated with libIK.generateSegment().
    endPos: (Vector)
        - The target end position of the limb.
    tiltDeg: (number)
        - How much to rotate the bendDir around lineDir.
        - 0 points to the right of lineDir, 90 points up, 180 points left, 270 points down.
        - For a humanoid model that starts in a T-pose, it's recommended to use 90 for legs, 0 for the right arm, and 180 for the left arm.
    applyImmediately: (boolean) (optional) (default: false)
        - Whether to apply the results immediately to the segment entities via :setPos() and :setAngles().

    RETURNS: startPos, bendPos, bendDir, segmentPosA, segmentAngA, segmentPosB, segmentAngB
        - May return nil if the parent entity of segmentA is invalid or endPos is unreasonable.
--]]
function libIK.twoSegByTilt( segmentA, segmentB, endPos, tiltDeg, applyImmediately )
    local parentEntA = segmentA._parentEnt
    if not isValid( parentEntA ) then return end

    local startPos = parentEntA:localToWorld( segmentA._parentToOrigin )
    local lineDir = endPos - startPos
    local L = lineDir:getLength()
    if L == 0 then return end

    lineDir = lineDir / L

    local LA = segmentA._length
    local LB = segmentB._length
    local bendDir = getIKBendFromTilt( segmentA, lineDir, tiltDeg )
    local bendPos = libIK.twoSeg( startPos, endPos, LA, LB, bendDir, lineDir, L )
    if not bendPos then return end

    local segmentPosA, segmentAngA = determineSegmentEntPosAng( segmentA, startPos, bendPos, bendDir )
    local segmentPosB, segmentAngB = determineSegmentEntPosAng( segmentB, bendPos, endPos, bendDir )

    if applyImmediately then
        local entA = segmentA._ent
        local entB = segmentB._ent

        entA:setPos( segmentPosA )
        entA:setAngles( segmentAngA )
        entB:setPos( segmentPosB )
        entB:setAngles( segmentAngB )
    end

    return startPos, bendPos, bendDir, segmentPosA, segmentAngA, segmentPosB, segmentAngB
end

--[[
    - libIK.twoSegByTilt() but for three segments.

    RETURNS: startPos, bendPos1, bendPos2, bendDir1, bendDir2, segmentPosA, segmentAngA, segmentPosB, segmentAngB, segmentPosC, segmentAngC
        - May return nil if the parent entity of segmentA is invalid or endPos is unreasonable.
--]]
function libIK.threeSegByTilt( segmentA, segmentB, segmentC, endPos, LX, tiltDeg1, tiltDeg2, applyImmediately )
    if LX <= 0 then return end

    local parentEntA = segmentA._parentEnt
    if not isValid( parentEntA ) then return end

    local startPos = parentEntA:localToWorld( segmentA._parentToOrigin )
    local lineDir1 = endPos - startPos
    local L = lineDir1:getLength()
    if L == 0 then return end

    lineDir1 = lineDir1 / L

    local LA = segmentA._length
    local LB = segmentB._length
    local LC = segmentC._length
    local bendDir1 = getIKBendFromTilt( segmentA, lineDir1, tiltDeg1 )
    local bendPos1 = libIK.twoSeg( startPos, endPos, LA, LX, bendDir1, lineDir1, L )
    if not bendPos1 then return end

    local lineDir2 = ( endPos - bendPos1 ) / LX
    local bendDir2 = getIKBendFromTilt( segmentB, lineDir2, tiltDeg2 )
    local bendPos2 = libIK.twoSeg( bendPos1, endPos, LB, LC, bendDir2, lineDir2, LX )
    if not bendPos2 then return end

    local segmentPosA, segmentAngA = determineSegmentEntPosAng( segmentA, startPos, bendPos1, bendDir1 )
    local segmentPosB, segmentAngB = determineSegmentEntPosAng( segmentB, bendPos1, bendPos2, bendDir2 )
    local segmentPosC, segmentAngC = determineSegmentEntPosAng( segmentC, bendPos2, endPos, bendDir2 )

    if applyImmediately then
        local entA = segmentA._ent
        local entB = segmentB._ent
        local entC = segmentC._ent

        entA:setPos( segmentPosA )
        entA:setAngles( segmentAngA )
        entB:setPos( segmentPosB )
        entB:setAngles( segmentAngB )
        entC:setPos( segmentPosC )
        entC:setAngles( segmentAngC )
    end

    return startPos, bendPos1, bendPos2, bendDir1, bendDir2, segmentPosA, segmentAngA, segmentPosB, segmentAngB, segmentPosC, segmentAngC
end

--[[
    - libIK.twoSegByTilt() but for four segments.

    RETURNS: startPos, bendPos1, bendPos2, bendPos3, bendDir1, bendDir2, bendDir3, segmentPosA, segmentAngA, segmentPosB, segmentAngB, segmentPosC, segmentAngC, segmentPosD, segmentAngD
        - May return nil if the parent entity of segmentA is invalid or endPos is unreasonable.
--]]
function libIK.fourSegByTilt( segmentA, segmentB, segmentC, segmentD, endPos, LX1, LX2, tiltDeg1, tiltDeg2, tiltDeg3, applyImmediately )
    if LX1 <= 0 or LX2 <= 0 then return end

    local parentEntA = segmentA._parentEnt
    if not isValid( parentEntA ) then return end

    local startPos = parentEntA:localToWorld( segmentA._parentToOrigin )
    local lineDir1 = endPos - startPos
    local L = lineDir1:getLength()
    if L == 0 then return end

    lineDir1 = lineDir1 / L

    local LA = segmentA._length
    local LB = segmentB._length
    local LC = segmentC._length
    local LD = segmentD._length
    local bendDir1 = getIKBendFromTilt( segmentA, lineDir1, tiltDeg1 )
    local bendPos1 = libIK.twoSeg( startPos, endPos, LA, LX1, bendDir1, lineDir1, L )
    if not bendPos1 then return end

    local lineDir2 = ( endPos - bendPos1 ) / LX1
    local bendDir2 = getIKBendFromTilt( segmentB, lineDir2, tiltDeg2 )
    local bendPos2 = libIK.twoSeg( bendPos1, endPos, LB, LC, bendDir2, lineDir2, LX1 )
    if not bendPos2 then return end

    local lineDir3 = ( endPos - bendPos2 ) / LX2
    local bendDir3 = getIKBendFromTilt( segmentC, lineDir3, tiltDeg3 )
    local bendPos3 = libIK.twoSeg( bendPos2, endPos, LC, LD, bendDir3, lineDir3, LX2 )
    if not bendPos3 then return end

    local segmentPosA, segmentAngA = determineSegmentEntPosAng( segmentA, startPos, bendPos1, bendDir1 )
    local segmentPosB, segmentAngB = determineSegmentEntPosAng( segmentB, bendPos1, bendPos2, bendDir2 )
    local segmentPosC, segmentAngC = determineSegmentEntPosAng( segmentC, bendPos2, bendPos3, bendDir3 )
    local segmentPosD, segmentAngD = determineSegmentEntPosAng( segmentD, bendPos3, endPos, bendDir3 )

    if applyImmediately then
        local entA = segmentA._ent
        local entB = segmentB._ent
        local entC = segmentC._ent
        local entD = segmentD._ent

        entA:setPos( segmentPosA )
        entA:setAngles( segmentAngA )
        entB:setPos( segmentPosB )
        entB:setAngles( segmentAngB )
        entC:setPos( segmentPosC )
        entC:setAngles( segmentAngC )
        entD:setPos( segmentPosD )
        entD:setAngles( segmentAngD )
    end

    return startPos, bendPos1, bendPos2, bendPos3, bendDir1, bendDir2, bendDir3, segmentPosA, segmentAngA, segmentPosB, segmentAngB, segmentPosC, segmentAngC, segmentPosD, segmentAngD
end


----- PRIVATE FUNCTIONS -----

getOBBSize = function( ent )
    local obbSize = ent:obbSize()

    if ent.getScale then
        obbSize = obbSize * ent:getScale()
    end

    return obbSize
end

getIKOffset = function( ent, parent, offset, offsetScaled, offsetFromParent, offsetFromParentScaled )
    local obbSizeHalf = getOBBSize( ent ) / 2

    offset = offset + offsetScaled * obbSizeHalf

    if offsetFromParent then
        if offsetFromParentScaled then
            local obbSizeParentHalf = getOBBSize( parent ) / 2

            offsetFromParent = offsetFromParent + offsetFromParentScaled * obbSizeParentHalf
        end

        offset = offset + ent:worldToLocal( parent:localToWorld( offsetFromParent ) )
    end

    return offset
end

sanitizeIK = function( startPos, endPos, LA, LB, bendDir, lineDir, L )
    L = L or startPos:getDistance( endPos )
    lineDir = lineDir or ( endPos - startPos ) / L
    bendDir = bendDir or lineDir:getAngle():getRight()

    local LMax = LA + LB

    if L > LMax then
        L = LMax
        endPos = startPos + lineDir * L
    end

    return endPos, bendDir, lineDir, L
end

getIKBendFromTilt = function( segment, lineDir, tiltDeg )
    local parentEnt = segment._parentEnt
    local upDir = parentEnt:localToWorldVector( segment._parentToUpDir )
    upDir = upDir:rotateAroundAxis( lineDir, -tiltDeg )

    local bendDir = lineDir:cross( upDir )
    local bendDirLengthSqr = bendDir:getLengthSqr()

    -- Ensure bendDir is a unit vector.
    if bendDirLength ~= 1 then
        -- Fallback option if upDir == lineDir.
        if bendDirLength == 0 then
            local forwardDir = parentEnt:localToWorldVector( segment._parentToForwardDir )
            forwardDir = forwardDir:rotateAroundAxis( lineDir, tiltDeg + 90 )

            -- In such cases, forwardDir and lineDir are guaranteed to be perpendicular, so crossing them is always length 1.
            return lineDir:cross( forwardDir )
        end

        bendDir = bendDir / mSqrt( bendDirLengthSqr )
    end

    return bendDir
end

determineSegmentEntPosAng = function( segment, targetStartPos, targetEndPos, bendDir )
    local targetDir = targetEndPos - targetStartPos -- targetAng should point in this direction, but we need upDir as well.
    local targetUp = targetDir:cross( bendDir ):cross( targetDir ) -- targetDir, bendDir, and upDir are all in the same plane, so cross twice to find upDir.
    local targetAng = targetDir:getAngleEx( targetUp )

    -- Account for ik offsets.
    return localToWorld( segment._originToEntPos, segment._originToEntAng, targetStartPos, targetAng )
end
