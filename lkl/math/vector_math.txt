--@name Vector Math
--@author legokidlogan
--@shared

vectorMath = vectorMath or {}

--[[
    - A library of assorted vector-based math functions.
    - For the sake of efficiency, these functions do not perform manual type checking, so take care with your input types.
    - (It goes without saying, but) any vector described as a 'direction,' a 'normal,' or being 'normalized' is a unit vector (length 1).
        - Any functions which has one of these as an argument will NOT check to ensure the correct length, for the sake of efficiency.
        - As such, be sure you pass a vector of the correct length, or you will get strange results.
--]]


if vectorMath.abs then return end


local PI = math.pi
local PI_HALF = PI / 2
local PI_DOUBLE = PI * 2
local VECTOR_ZERO = Vector( 0, 0, 0 )
local ANGLE_ZERO = Angle( 0, 0, 0 )
local PRECISION_TINY = math.pow( 10, -5 )

local mAbs = math.abs
local mSign = math.sign
local mSqrt = math.sqrt
local mMin = math.min
local mMax = math.max
local mClamp = math.clamp
local mCos = math.cos
local mSin = math.sin
local mTan = math.tan
local mACos = math.acos
local mATan = math.atan
local mRand = math.rand
local mRandom = math.random
local mLerpVector = math.lerpVector

local getArgsAsTable
local isXCloseToY
local getCylinderBottomAndDirEff
local getConeEndRadius
local getPlaneNormal


--[[
    - Performs math.abs() on all components of a vector.

    vec: (Vector)
        - The vector to perform the operation on.
--]]
function vectorMath.abs( vec )
    return Vector(
        mAbs( vec[1] ),
        mAbs( vec[2] ),
        mAbs( vec[3] )
    )
end

--[[
    - Returns a rounded copy of a vector.
    - Same as Vector:round() in starfall, but returns instead of self-modifying.

    vec: (Vector)
        - The vector to round.
    idp: (optional) (number >= 0)
        - The number of decimal places to round to.
        - Default is 0.
--]]
function vectorMath.round( vec, idp )
    vec = vec:clone()
    vec:round( idp )

    return vec
end

--[[
    - Compares two vectors by their lengths and returns the shorter one, its length, and the longer vector's length.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.

    RETURNS: minVec, minVecLength, maxVecLength
        minVec: (Vector)
            - The shorter of the two vectors.
                - If they are the same length, vec1 is returned.
            - This is passed by reference, not by value!
                - This means that modifying the returned minVec will alter either vec1 or vec2.
        minVecLength: (number)
            - The length of the shorter vector.
        maxVecLength: (number)
            - The length of the longer vector.
--]]
function vectorMath.minBylength( vec1, vec2 )
    local length1 = vec1:getLength()
    local length2 = vec2:getLength()

    if length1 <= length2 then return vec1, length1, length2 end

    return vec2, length2, length1
end

--[[
    - Compares two vectors by their lengths and returns the shorter one.
    - This is the same as vectorMath.minBylength(), but doesn't return any lengths, just the one vector result.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.

    RETURNS: minVec
        minVec: (Vector)
            - The shorter of the two vectors.
                - If they are the same length, vec1 is returned.
            - This is passed by reference, not by value!
                - This means that modifying the returned minVec will alter either vec1 or vec2.
--]]
function vectorMath.minVectorBylength( vec1, vec2 )
    local length1 = vec1:getLengthSqr()
    local length2 = vec2:getLengthSqr()

    if length1 <= length2 then return vec1 end

    return vec2
end

--[[
    - Returns a vector consisting of the piecewise (i.e. per-axis) minimum values of two vectors.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.
--]]
function vectorMath.minPiecewise( vec1, vec2 )
    return Vector(
        mMin( vec1[1], vec2[1] ),
        mMin( vec1[2], vec2[2] ),
        mMin( vec1[3], vec2[3] )
    )
end

--[[
    - Returns a vector consisting of the piecewise (i.e. per-axis) minimum values of an arbitrary number of vectors.
    - The vectors can either be given as individual arguments or one single sequential table of vectors.
--]]
function vectorMath.minPiecewiseMulti( ... )
    local args = getArgsAsTable( ... )
    local argCount = #args

    if argCount == 0 then return end
    if argCount == 1 then return args[1]:clone() end

    local minVec = args[1]:clone()

    for i = 2, argCount do
        local vec = args[i]

        minVec[1] = mMin( minVec[1], vec[1] )
        minVec[2] = mMin( minVec[2], vec[2] )
        minVec[3] = mMin( minVec[3], vec[3] )
    end

    return minVec
end

--[[
    - Compares two vectors by their lengths and returns the longer one, its length, and the shorter vector's length.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.

    RETURNS: maxVec, maxVecLength, minVecLength
        maxVec: (Vector)
            - The longer of the two vectors.
                - If they are the same length, vec1 is returned.
            - This is passed by reference, not by value!
                - This means that modifying the returned maxVec will alter either vec1 or vec2.
        maxVecLength: (number)
            - The length of the longer vector.
        minVecLength: (number)
            - The length of the shorter vector.
--]]
function vectorMath.maxByLength( vec1, vec2 )
    local length1 = vec1:getLength()
    local length2 = vec2:getLength()

    if length1 >= length2 then return vec1, length1, length2 end

    return vec2, length2, length1
end

--[[
    - Compares two vectors by their lengths and returns the longer one.
    - This is the same as vectorMath.maxBylength(), but doesn't return any lengths, just the one vector result.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.

    RETURNS: maxVec
        maxVec: (Vector)
            - The longer of the two vectors.
                - If they are the same length, vec1 is returned.
            - This is passed by reference, not by value!
                - This means that modifying the returned maxVec will alter either vec1 or vec2.
--]]
function vectorMath.maxVectorByLength( vec1, vec2 )
    local length1 = vec1:getLengthSqr()
    local length2 = vec2:getLengthSqr()

    if length1 >= length2 then return vec1 end

    return vec2
end

--[[
    - Returns a vector consisting of the piecewise (i.e. per-axis) maximum values of two vectors.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.
--]]
function vectorMath.maxPiecewise( vec1, vec2 )
    return Vector(
        mMax( vec1[1], vec2[1] ),
        mMax( vec1[2], vec2[2] ),
        mMax( vec1[3], vec2[3] )
    )
end

--[[
    - Returns a vector consisting of the piecewise (i.e. per-axis) maximum values of an arbitrary number of vectors.
    - The vectors can either be given as individual arguments or one single sequential table of vectors.
--]]
function vectorMath.maxPiecewiseMulti( ... )
    local args = getArgsAsTable( ... )
    local argCount = #args

    if argCount == 0 then return end
    if argCount == 1 then return args[1]:clone() end

    local maxVec = args[1]:clone()

    for i = 2, argCount do
        local vec = args[i]

        maxVec[1] = mMax( maxVec[1], vec[1] )
        maxVec[2] = mMax( maxVec[2], vec[2] )
        maxVec[3] = mMax( maxVec[3], vec[3] )
    end

    return maxVec
end

-- Returns the min and max bounds of a table or vararg of Vectors.
function vectorMath.getMinMaxPiecewise( points, ... )
    if type( points ) == "Vector" then
        points = { points, ... }
    end

    local pointCount = #points
    if pointCount == 0 then return nil end
    if pointCount == 1 then return points[1]:clone() end

    local minX = math.huge
    local minY = math.huge
    local minZ = math.huge
    local maxX = -math.huge
    local maxY = -math.huge
    local maxZ = -math.huge

    for i = 1, pointCount do
        local point = points[i]
        local x = point[1]
        local y = point[2]
        local z = point[3]

        if x < minX then minX = x end
        if x > maxX then maxX = x end
        if y < minY then minY = y end
        if y > maxY then maxY = y end
        if z < minZ then minZ = z end
        if z > maxZ then maxZ = z end
    end

    return Vector( minX, minY, minZ ), Vector( maxX, maxY, maxZ )
end

--[[
    - Scales a vector so that its length is clamped between a min and max.

    vec: (Vector)
        - The vector to be clamped.
        - If its length is zero, it will be returned as-is, since scaling would do nothing.
    minLength: (number)
        - The minimum length of the output vector.
        - Behavior is poorly defined if this value is negative.
    maxLength: (number)
        - The maximum length of the output vector.
        - Behavior is poorly defined if this value is negative.
--]]
function vectorMath.clampByLength( vec, minLength, maxLength )
    local dir, length = vectorMath.getDirectionAndLength( vec )
    if length == 0 then return Vector( 0, 0, 0 ) end

    length = mClamp( length, minLength, maxLength )

    return dir * length
end

--[[
    - Returns a vector with each component clamped between a separate min and max value.

    vec: (Vector)
        - The vector to be clamped.
    minVec: (Vector)
        - The minimum values for each component of the output vector.
    maxVec: (Vector)
        - The maximum values for each component of the output vector.
--]]
function vectorMath.clampPiecewise( vec, minVec, maxVec )
    return Vector(
        mClamp( vec[1], minVec[1], maxVec[1] ),
        mClamp( vec[2], minVec[2], maxVec[2] ),
        mClamp( vec[3], minVec[3], maxVec[3] )
    )
end

--[[
    - Adds a single vector to each vector in a list.

    vec: (Vector)
        - The vector to add to each vector in the list.
    vecs: (table)
        - A sequential table of vectors.
    doSelfModify: (optional) (boolean)
        - If true, will modify the input vecs table directly.
        - If false, will return a new table of vectors.
        - Default is false.
--]]
function vectorMath.addToVectors( vec, vecs, doSelfModify )
    if doSelfModify then
        for i = 1, #vecs do
            vecs[i] = vecs[i] + vec
        end

        return vecs
    end

    local newVecs = {}

    for i = 1, #vecs do
        newVecs[i] = vecs[i] + vec
    end

    return newVecs
end

--[[
    - Performs piecewise (i.e. per-axis) addition of a vector onto other vectors in a list.

    vec: (Vector)
        - The vector to multiply against each vector in the list.
    vecs: (table)
        - A sequential table of vectors.
    doSelfModify: (optional) (boolean)
        - If true, will modify the input vecs table directly.
        - If false, will return a new table of vectors.
        - Default is false.
--]]
function vectorMath.multiplyAgainstVectors( vec, vecs, doSelfModify )
    if doSelfModify then
        for i = 1, #vecs do
            vecs[i] = vecs[i] * vec
        end

        return vecs
    end

    local newVecs = {}

    for i = 1, #vecs do
        newVecs[i] = vecs[i] * vec
    end

    return newVecs
end

--[[
    - Takes a vector and splits it into its unit direction and length.
    - Best used for cases where the length might be zero and needs to be safely accounted for.

    vec: (Vector)
        - The vector to split apart.

    RETURNS: dir, length
        dir: (Vector)
            - A normalized (length 1) version of the input vector.
        length: (number)
            - The length of the input vector.
--]]
function vectorMath.getDirectionAndLength( vec )
    if vec == VECTOR_ZERO then return Vector( 0, 0, 0 ), 0 end -- Doesn't return vec itself to prevent reference sharing.

    local length = vec:getLength()

    return vec / length, length
end

--[[
    - Calculates the axis-alligned, position-local bounding box for local min/max corners at a given scale and rotation.
    - 'Position-local' means the aabb has been adjusted to account for the object's angles, but not its position.
        - To make the aabb be in true world coordinates, just add your object's position to the returned mins and maxs.

    obbMins: (Vector)
        - The local minimum corner of the OBB.
    obbMaxs: (Vector)
        - The local maximum corner of the OBB.
    ang: (optional) (Angle)
        - The rotation of the OBB.
        - Default is Angle( 0, 0, 0 ).
    scale: (optional) (Vector)
        - The scale of the OBB.
        - Default is Vector( 1, 1, 1 ).

    RETURNS: aabbMins, aabbMaxs
        aabbMins: (Vector)
            - The position-local minimum corner of the AABB.
        aabbMaxs: (Vector)
            - The position-local maximum corner of the AABB.
--]]
function vectorMath.getAABB( obbMins, obbMaxs, ang, scale )
    if scale then
        obbMins = obbMins * scale
        obbMaxs = obbMaxs * scale
    end

    if not ang or ang == ANGLE_ZERO then return obbMins:clone(), obbMaxs:clone() end

    local minX = obbMins[1]
    local minY = obbMins[2]
    local minZ = obbMins[3]
    local maxX = obbMaxs[1]
    local maxY = obbMaxs[2]
    local maxZ = obbMaxs[3]

    local corners = {
        obbMins:getRotated( ang ),
        Vector( minX, maxY, minZ ):getRotated( ang ),
        Vector( maxX, minY, minZ ):getRotated( ang ),
        Vector( maxX, maxY, minZ ):getRotated( ang ),
        obbMaxs:getRotated( ang ),
        Vector( maxX, minY, maxZ ):getRotated( ang ),
        Vector( minX, maxY, maxZ ):getRotated( ang ),
        Vector( minX, minY, maxZ ):getRotated( ang ),
    }

    local aabbMins = vectorMath.minPiecewiseMulti( corners )
    local aabbMaxs = vectorMath.maxPiecewiseMulti( corners )

    return aabbMins, aabbMaxs
end

--[[
    - Calculates the position-local center of an OBB at a given scale and rotation.
    - 'Position-local' means the center has been adjusted to account for the object's angles, but not its position.
        - To make the center be in true world coordinates, just add your object's position to the returned center.

    obbMins: (Vector)
        - The local minimum corner of the OBB.
    obbMaxs: (Vector)
        - The local maximum corner of the OBB.
    ang: (optional) (Angle)
        - The rotation of the OBB.
        - Default is Angle( 0, 0, 0 ).
    scale: (optional) (Vector)
        - The scale of the OBB.
        - Default is Vector( 1, 1, 1 ).
--]]
function vectorMath.getOBBCenter( obbMins, obbMaxs, ang, scale )
    local center = ( obbMins + obbMaxs ) / 2

    if scale then
        center = center * scale
    end

    if ang and ang ~= ANGLE_ZERO then
        center:rotate( ang )
    end

    return center
end

-- Gets the average of a sequential table of Vectors.
function vectorMath.getAverage( points )
    local sumX = 0
    local sumY = 0
    local sumZ = 0
    local pointCount = #points

    for i = 1, pointCount do
        local point = points[i]

        sumX = sumX + point[1]
        sumY = sumY + point[2]
        sumZ = sumZ + point[3]
    end

    return Vector( sumX / pointCount, sumY / pointCount, sumZ / pointCount )
end

-- Returns the midpoint of the bounds of a table or a vararg of Vectors.
function vectorMath.getCenter( points, ... )
    local min, max = vectorMath.getMinMaxPiecewise( points, ... )

    return ( min + max ) / 2
end

--[[
    - Returns a table of vectors fanning out from a given direction.

    dir: (Vector or Angle)
        - The central direction to fan out from.
        - Will use :getUp() to determine the rotation axis for the fan.
            - i.e. the fan will rotate along its yaw axis.
    count: (number >= 1)
        - The number of vectors to return.
    separationDeg: (number >= 0)
        - The amount of degrees to separate each vector by.
--]]
function vectorMath.makeFan( dir, count, separationDeg )
    if count < 1 then return {} end
    if count == 1 then
        if type( dir ) == "Angle" then return { dir:getForward() } end

        return { dir:clone() }
    end

    local rotAxis

    if type( dir ) == "Angle" then
        rotAxis = dir:getUp()
        dir = dir:getForward()
    else
        rotAxis = dir:getAngle():getUp()
    end

    local prevVec = dir:rotateAroundAxis( rotAxis, -separationDeg * ( count - 1 ) / 2 )
    local fanVecs = { prevVec }

    for i = 2, count do
        prevVec = prevVec:rotateAroundAxis( rotAxis, separationDeg )
        fanVecs[i] = prevVec
    end

    return fanVecs
end

--[[
    - Returns a table of vectors fanning out from a given direction.

    dir: (Vector or Angle)
        - The central direction to fan out from.
        - Will use :getUp() to determine the rotation axis for the fan.
            - i.e. the fan will rotate along its yaw axis.
    count: (number >= 1)
        - The number of vectors to return.
    totalDeg: (number >= 0)
        - The amount of degrees to spread the fan across, with each vector being evenly spaced.
--]]
function vectorMath.makeFanWithin( dir, count, totalDeg )
    if count <= 1 then return vectorMath.makeFan( dir, count ) end

    return vectorMath.makeFan( dir, count, totalDeg / ( count - 1 ) )
end

--[[
    - Takes a unit vector and returns a copy that's been rotated randomly within a given pitch and yaw range.
    - Useful for adding spread to projectiles.
    - ex:
        - vectorMath.spreadVector( vec, -10, 10, -10, 10 ) -> A circular spread of radius 10 degrees.
            - Equivalent to vectorMath.spreadVector( vec, 10 )
        - vectorMath.spreadVector( vec, -10, 10, -20, 20 ) -> An elliptical spread of pitch/yaw radii of 10/20 degrees.
            - Equivalent to vectorMath.spreadVector( vec, 10, nil, 20 )
        - vectorMath.spreadVector( vec, 10, 15, -180, 180 ) -> A circular ring spread between radii 10 and 15 degrees.

    dir: (Vector)
        - The unit vector to spread.
    pitchMin: (-180 <= number <= 180)
        - The minimum pitch angle to spread by, in degrees.
    pitchMax: (optional) (-180 <= number <= 180)
        - The maximum pitch angle to spread by, in degrees.
        - If nil, defaults to -pitchMin.
    yawMin: (optional) (-180 <= number <= 180)
        - The minimum yaw angle to spread by, in degrees.
        - If nil, defaults to pitchMin.
    yawMax: (optional) (-180 <= number <= 180)
        - The maximum yaw angle to spread by, in degrees.
        - If nil, defaults to -yawMin or pitchMax, depending on which is provided.
--]]
function vectorMath.spreadVector( dir, pitchMin, pitchMax, yawMin, yawMax )
    pitchMax = pitchMax or -pitchMin -- math.rand() still works even if min > max, so we don't need to swap the order.
    yawMax = yawMax or ( yawMin and -yawMin ) or pitchMax
    yawMin = yawMin or pitchMin

    if pitchMin == 0 and pitchMax == 0 and yawMin == 0 and yawMax == 0 then return dir:clone() end

    local pitchDeg = mRand( pitchMin, pitchMax )
    local yawDeg = mRand( yawMin, yawMax )

    local ang = dir:getAngle()
    local right = ang:getRight()
    local up = ang:getUp()

    ang = ang:rotateAroundAxis( right, pitchDeg )
    ang = ang:rotateAroundAxis( up, yawDeg )

    return ang:getForward()
end

--[[
    - Returns a randomized vector with a min-max range for each component.

    xMin: (optional) (number)
        - Defaults to 0.
    xMax: (optional) (number)
        - Defaults to 1.
    yMin: (optional) (number)
        - Defaults to xMin.
    yMax: (optional) (number)
        - Defaults to xMax.
    zMin: (optional) (number)
        - Defaults to xMin.
    zMax: (optional) (number)
        - Defaults to xMax.
--]]
function vectorMath.randomVector( xMin, xMax, yMin, yMax, zMin, zMax )
    xMin = xMin or 0
    xMax = xMax or 1

    return Vector(
        mRand( xMin, xMax ),
        mRand( yMin or xMin, yMax or xMax ),
        mRand( zMin or xMin, zMax or xMax )
    )
end

-- Returns a random unit vector.
function vectorMath.randomDirection()
    local x = mRand( -1, 1 )
    local y = mRand( -1, 1 )
    local z = mRand( -1, 1 )

    if x == 0 and y == 0 and z == 0 then return Vector( 1, 0, 0 ) end

    return Vector( x, y, z ):getNormalized()
end

--[[
    - Finds the optimal launch direction for a simple projectile to hit a target.
    - This assumes z-axis gravity and no air resistance.

    startPos: (Vector)
        - The initial position of the projectile.
    targetPos: (Vector)
        - The position of the target.
    projSpeed: (number > 0)
        - The initial speed of the projectile.
    gravity: (optional) (number)
        - Acceleration due to gravity.
        - Negative values mean a downwards-facing pull of gravity.
        - Defaults to the z-axis of physenv.getGravity().
    doUpperAngle: (optional) (boolean)
        - If true, will use the higher-aiming angle of the two possible solutions.

    - Note that, if you use this for gmod physics objects, the Source engine still applies drag even with :enableDrag( false )
        - You will need to disable gravity and then, every tick, set the velocity and account for gravity to maintain the correct speed.
        - Rough example:
            local dir = vectorMath.dirForProjectile( startPos, targetPos, projSpeed, gravity )
            local vel = dir * projSpeed
            local hookName = "SomeUniqueHookName_MaintainSpeed" -- Should be something unique to that projectile to prevent naming conflicts.

            ent:setPos( startPos )
            ent:setAngles( dir:getAngle() )

            physObj:enableGravity( false )
            physObj:emableMotion( true )
            physObj:setVelocity( dir * projSpeed )

            ent:addCollisionListener( function( colData )
                if not vel then return end -- Sometimes collision listeners can trigger after being removed, due to coming from the physics thread.

                vel = false
                hook.remove( "think", hookName )
                ent:removeCollisionListener()

                doStuffOnImpact( colData )
            end )

            hook.add( "think", hookName, function()
                if not physObj:isValid() then
                    hook.remove( "think", hookName )
                    return
                end

                vel[3] = vel[3] + gravity * timer.frametime()
                physObj:setVelocity( vel )
            end )
--]]
function vectorMath.dirForProjectile( startPos, targetPos, projSpeed, gravity, doUpperAngle )
    gravity = -( gravity or physenv.getGravity()[3] )

    if gravity == 0 then
        return ( targetPos - startPos ):getNormalized()
    end

    local targetDelta = targetPos - startPos
    local targetDeltaZ = targetDelta[3]
    local targetDeltaHoriz = Vector( targetDelta[1], targetDelta[2], 0 )

    local projSpeedSqr = projSpeed ^ 2
    local distHoriz = targetDeltaHoriz:getLength()

    if distHoriz == 0 then
        local dir = vectormath.getDirectionAndLength( targetDelta )

        return dir
    end

    local yaw = targetDelta:getAngle()[2]
    local pitch
    local plusMinus = doUpperAngle and 1 or -1

    local theta = math.deg( math.atan(
        ( projSpeedSqr + plusMinus * math.sqrt( projSpeedSqr ^ 2 - gravity * ( gravity * distHoriz ^ 2 + 2 * targetDeltaZ * projSpeedSqr ) ) )
        / ( gravity * distHoriz )
    ) )

    if theta ~= theta then -- nan
        local sign = targetDelta:getAngle()[1] > 0 and 1 or -1

        theta = 89 * sign
    end

    pitch = -theta

    return Angle( pitch, yaw, 0 ):getForward()
end

--[[
    - Returns the width and height of the smallest plane containing a set of points.
    - Assumes the points all lie along a flat plane.
    - For use with things like map brushes/surfaces, which are flat but arbitrarily complex polygons.
        - Note that all of the three required args can be obtained from brush/surface info.

    planePoints: (table)
        - A sequential table of vectors representing the points of the plane.
        - Must lie flat along a plane, or the results will be garbage.
    planeNormalAng: (Vector or Angle)
        - The normal of the plane.
    planeCenter: (optional) (Vector)
        - The center of the plane, based on the midpoint of its min and max AABB bounds.
        - If nil, will be calculated from the points.

    RETURNS: planeWidth, planeHeight
        planeWidth: (number)
            - The width of the plane.
        planeHeight: (number)
            - The height of the plane.
--]]
function vectorMath.getPlaneSize( planePoints, planeNormalAng, planeCenter )
    planeCenter = planeCenter or vectorMath.getCenter( points )

    if type( planeNormalAng ) == "Vector" then
        planeNormalAng = planeNormalAng:getAngle()
    end

    local planeMinX = math.huge
    local planeMinY = math.huge
    local planeMaxX = -math.huge
    local planeMaxY = -math.huge

    for _, point in ipairs( planePoints ) do
        local localPoint = worldToLocal( point, ANGLE_ZERO, planeCenter, planeNormalAng ) -- Local to the plane
        local pointX = localPoint[2] -- Local to the plane, with x along width, y along height
        local pointY = localPoint[3]

        if pointX < planeMinX then planeMinX = pointX end
        if pointY < planeMinY then planeMinY = pointY end
        if pointX > planeMaxX then planeMaxX = pointX end
        if pointY > planeMaxY then planeMaxY = pointY end
    end

    local planeWidth = planeMaxX - planeMinX
    local planeHeight = planeMaxY - planeMinY

    return planeWidth, planeHeight
end

--[[
    - Retuns the minimal distance between a point and an infinite line.

    point: (Vector)
        - The point to measure the distance from.
    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
--]]
function vectorMath.pointDistanceFromLine( point, lineOrigin, lineDir )
    -- Taken from steps 1-3 of https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html and optimized for dir being a unit vector.
    local pointToOrigin = lineOrigin - point
    local projLength = pointToOrigin:dot( lineDir )

    return ( pointToOrigin - lineDir * projLength ):getLength()
end

--[[
    - Retuns the minimal distance between a point and a line segment.

    point: (Vector)
        - The point to measure the distance from.
    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
--]]
function vectorMath.pointDistanceFromLineSegment( point, segmentStart, segmentEnd )
    local segmentDir, segmentLength = vectorMath.getDirectionAndLength( segmentEnd - segmentStart )
    if segmentLength == 0 then return ( point - segmentStart ):getLength() end

    local pointToStart = segmentStart - point
    local pointToEnd = segmentEnd - point
    local toStartProj = pointToStart:dot( segmentDir )
    local toEndProj = pointToEnd:dot( segmentDir )

    if toStartProj <= 0 and toEndProj >= 0 then
        -- The point is inside an infinite-radius cylinder made by the segment.
        -- Therefore, treat it the same as a regular point-line distance problem.
        return ( pointToStart - segmentDir * toStartProj ):getLength()
    end

    -- Point is closer to the start, get distance from it.
    if mAbs( toStartProj ) < mAbs( toEndProj ) then
        return segmentStart:getDistance( point )
    end

    -- Point is closer to the end, get distance from it.
    return segmentEnd:getDistance( point )
end

--[[
    - Retuns the minimal distance between a point an infinite plane.

    point: (Vector)
        - The point to measure the distance from.
    planeOrigin: (Vector)
        - A point on the plane.
    planeNormal: (Vector)
        - The normal of the plane.
--]]
function vectorMath.pointDistanceFromPlane( point, planeOrigin, planeNormal )
    -- Taken from https://mathinsight.org/distance_point_plane
    local originToPoint = point - planeOrigin

    return mAbs( originToPoint:dot( planeNormal ) )
end

--[[
    - Returns the distance between two infinite lines.

    lineOrigin1: (Vector)
        - A point on the first line.
    lineDir1: (Vector)
        - The direction of the first line.
    lineOrigin2: (Vector)
        - A point on the second line.
    lineDir2: (Vector)
        - The direction of the second line.
    precision: (optional) (number >= 0)
        - A cutoff point for considring the lines parallel.
        - Values of 1 and above will result in it always thinking the lines are parallel.
        - Default is 10^-5.

    RETURNS: dist, cross
        dist: (number)
            - The distance between the two lines.
        crossUnit: (Vector or nil)
            - A direction vector perpendicular to both lines, roughly pointing from the first line to the second.
            - If the lines are parallel, this is nil.
--]]
function vectorMath.lineDistanceFromLine( lineOrigin1, lineDir1, lineOrigin2, lineDir2, precision )
    precision = precision or PRECISION_TINY

    local cross = lineDir1:cross( lineDir2 )
    local crossLength = cross:getLength()

    if crossLength <= precision then
        -- Parallel lines.
        return vectorMath.pointDistanceFromLine( lineOrigin1, lineOrigin2, lineDir2 )
    end

    local crossUnit = cross / crossLength
    local dist = crossUnit:dot( lineOrigin2 - lineOrigin1 )

    if dist < 0 then
        dist = -dist
        crossUnit = -crossUnit
    end

    return dist, crossUnit
end

--[[
    - Returns the closest pair of points between two infinite lines.

    lineOrigin1: (Vector)
        - A point on the first line.
    lineDir1: (Vector)
        - The direction of the first line.
    lineOrigin2: (Vector)
        - A point on the second line.
    lineDir2: (Vector)
        - The direction of the second line.
    precision: (optional) (number >= 0)
        - A cutoff point for considring the lines parallel.
        - Values of 1 and above will result in it always thinking the lines are parallel.
        - Default is 10^-5.

    RETURNS: closest1, closest2, t1, t2
        closest1: (Vector)
            - The closest point on the first line.
        closest2: (Vector)
            - The closest point on the second line.
        t1: (number)
            - The signed distance along the first line to reach closest1 from lineOrigin1.
            - Exactly 0 if the lines are parallel.
        t2: (number)
            - The signed distance along the second line to reach closest2 from lineOrigin2.
--]]
function vectorMath.closestPointsBetweenLines( lineOrigin1, lineDir1, lineOrigin2, lineDir2, precision )
    precision = precision or PRECISION_TINY

    local cross = lineDir1:cross( lineDir2 )
    local crossLengthSqr = cross:getLengthSqr()
    local crossLength = mSqrt( crossLengthSqr )

    if crossLength <= precision then
        -- Parallel lines.
        local closest2 = vectorMath.closestPointOnLine( lineOrigin1, lineOrigin2, lineDir2 )

        return lineOrigin1:clone(), closest2, 0, ( closest2 - lineOrigin2 ):dot( lineDir2 )
    end

    local diff = lineOrigin2 - lineOrigin1
    local t1 = lineDir2:cross( cross ):dot( diff ) / crossLengthSqr
    local t2 = lineDir1:cross( cross ):dot( diff ) / crossLengthSqr

    local closest1 = lineOrigin1 + lineDir1 * t1
    local closest2 = lineOrigin2 + lineDir2 * t2

    return closest1, closest2, t1, t2
end

--[[
    - Returns the closest point on an infinite line to a given point.

    point: (Vector)
        - The point to find the closest point to.
    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
--]]
function vectorMath.closestPointOnLine( point, lineOrigin, lineDir )
    local pointToOrigin = lineOrigin - point
    local projLength = pointToOrigin:dot( lineDir )

    return lineOrigin - lineDir * projLength
end

--[[
    - Returns the closest point on a line segment to a given point.

    point: (Vector)
        - The point to find the closest point to.
    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
--]]
function vectorMath.closestPointOnLineSegment( point, segmentStart, segmentEnd )
    local segmentDir, segmentLength = vectorMath.getDirectionAndLength( segmentEnd - segmentStart )
    if segmentLength == 0 then return segmentStart:clone() end

    local pointToStart = segmentStart - point
    local pointToEnd = segmentEnd - point
    local toStartProj = pointToStart:dot( segmentDir )
    local toEndProj = pointToEnd:dot( segmentDir )

    if toStartProj == 0 or toEndProj == 0 or ( mSign( toStartProj ) == -1 and mSign( toEndProj ) == 1 ) then
        -- The point is inside an infinite-radius cylinder made by the segment.
        -- Therefore, treat it the same as a regular point-line problem.
        return segmentStart - segmentDir * toStartProj
    end

    -- Point is closer to the start.
    if mAbs( toStartProj ) < mAbs( toEndProj ) then
        return segmentStart:clone()
    end

    -- Point is closer to the end.
    return segmentEnd:clone()
end

--[[
    - Returns the closest point on a plane to a given point.

    point: (Vector)
        - The point to find the closest point to.
    planeOrigin: (Vector)
        - The center of the plane.
    planeNormalAng: (Angle or Vector)
        - The normal of the plane.
        - If planeWidth is provided, it's recommended to have this as an Angle.
    planeWidth: (optional) (number)
        - The width of the plane.
        - If nil, will be an infinite plane.
    planeHeight: (optional) (number)
        - The height of the plane.
        - Defaults to the value of planeWidth.
--]]
function vectorMath.closestPointOnPlane( point, planeOrigin, planeNormalAng, planeWidth, planeHeight )
    local planeNormal
    planeNormal, planeNormalAng = getPlaneNormal( planeNormalAng )

    local originToPoint = point - planeOrigin
    local closestPoint = point - planeNormal * originToPoint:dot( planeNormal )
    if not planeWidth then return closestPoint end

    planeHeight = planeHeight or planeWidth
    local planeWidthHalf = planeWidth / 2
    local planeHeightHalf = planeHeight / 2

    local planeRight = planeNormalAng:getRight()
    local planeUp = planeNormalAng:getUp()
    local closestPointToOrigin = closestPoint - planeOrigin

    local rightLength = mClamp( closestPointToOrigin:dot( planeRight ), -planeWidthHalf, planeWidthHalf )
    local upLength = mClamp( closestPointToOrigin:dot( planeUp ), -planeHeightHalf, planeHeightHalf )

    return planeOrigin + planeRight * rightLength + planeUp * upLength
end

--[[
    - Gets the intersection point between two infinite lines.

    lineOrigin1: (Vector)
        - A point on the first line.
    lineDir1: (Vector)
        - The direction of the first line.
    lineOrigin2: (Vector)
        - A point on the second line.
    lineDir2: (Vector)
        - The direction of the second line.
    precision: (optional) (number >= 0)
        - The maximum distance between the lines for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 10^-5.

    RETURNS: intersectionPoint
        intersectionPoint: (Vector or nil)
            - The point where the two lines intersect, or nil if they don't.
--]]
function vectorMath.lineIntersectionWithLine( lineOrigin1, lineDir1, lineOrigin2, lineDir2, precision )
    precision = precision or PRECISION_TINY

    if vectorMath.isPointOnPoint( lineDir1, lineDir2, PRECISION_TINY ) then
        local intersectionPoint = ( lineOrigin1 + lineOrigin2 ) / 2

        if vectorMath.isPointOnLine( intersectionPoint, lineOrigin1, lineDir1, precision ) then
            return intersectionPoint
        end

        return
    end

    local dir1X = lineDir1[1]
    local dir1Y = lineDir1[2]
    local dir1Z = lineDir1[3]
    local dir2X = lineDir2[1]
    local dir2Y = lineDir2[2]
    local dir2Z = lineDir2[3]
    local t1
    local t2

    if dir1X == 0 then
        if dir1Y == 0 then
            if dir1Z == 0 then
                if vectorMath.isPointOnPoint( lineOrigin1, lineOrigin2, precision ) then
                    return ( lineOrigin1 + lineOrigin2 ) / 2
                end

                return
            end

            if dir2X == 0 and dir2Y == 0 then
                if vectorMath.isPointOnPoint( Vector( lineOrigin1[1], lineOrigin1[2], 0 ), Vector( lineOrigin2[1], lineOrigin2[2], 0 ), precision ) then
                    return ( lineOrigin1 + lineOrigin2 ) / 2
                end
            else
                return vectorMath.lineIntersectionWithLine( lineOrigin2, lineDir2, lineOrigin1, lineDir1, precision )
            end
        end
    elseif not isXCloseToY( dir1Y / dir1X, dir2Y / dir2X, PRECISION_TINY ) then
        local div = dir2Y - dir2X * dir1Y / dir1X

        if div ~= 0 then
            local originDiffX = lineOrigin2[1] - lineOrigin1[1]

            t2 = ( lineOrigin1[2] - lineOrigin2[2] + dir1Y * originDiffX / dir1X ) / div
            t1 = ( originDiffX + dir2X * t2 ) / dir1X
        end
    end

    if not t1 then
        if dir1Y == 0 then return end

        local div = dir2Z - dir2Y * dir1Z / dir1Y
        if div == 0 then return end

        local originDiffY = lineOrigin2[2] - lineOrigin1[2]

        t2 = ( lineOrigin1[3] - lineOrigin2[3] + dir1Z * originDiffY / dir1Y ) / div
        t1 = ( originDiffY + dir2Y * t2 ) / dir1Y
    end

    local point1 = lineOrigin1 + lineDir1 * t1
    local point2 = lineOrigin2 + lineDir2 * t2

    if point1 == point2 then return point1 end

    if vectorMath.isPointOnPoint( point1, point2, precision ) then
        return ( point1 + point2 ) / 2
    end
end

--[[
    - Returns the intersection point between two line segments.

    segmentStart1: (Vector)
        - The start of the first line segment.
    segmentEnd1: (Vector)
        - The end of the first line segment.
    segmentStart2: (Vector)
        - The start of the second line segment.
    segmentEnd2: (Vector)
        - The end of the second line segment.
    precision: (optional) (number >= 0)
        - The maximum distance between the line segments for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 10^-5.

    RETURNS: intersectionPoint
        intersectionPoint: (Vector or nil)
            - The intersection point of the two line segments, or nil if they don't intersect.
--]]
function vectorMath.lineSegmentIntersectionWithLineSegment( segmentStart1, segmentEnd1, segmentStart2, segmentEnd2, precision )
    precision = precision or PRECISION_TINY

    local segmentDir1, segmentLength1 = vectorMath.getDirectionAndLength( segmentEnd1 - segmentStart1 )
    local segmentDir2, segmentLength2 = vectorMath.getDirectionAndLength( segmentEnd2 - segmentStart2 )
    local segmentMiddle1 = segmentStart1 + segmentDir1 * segmentLength1 / 2
    local segmentMiddle2 = segmentStart2 + segmentDir2 * segmentLength2 / 2

    local intersectionPoint = vectorMath.lineIntersectionWithLine( segmentMiddle1, segmentDir1, segmentMiddle2, segmentDir2, precision )
    if not intersectionPoint then return end

    if not vectorMath.isPointOnLineSegment( intersectionPoint, segmentStart1, segmentEnd1, precision ) then return end
    if not vectorMath.isPointOnLineSegment( intersectionPoint, segmentStart2, segmentEnd2, precision ) then return end

    return intersectionPoint
end

--[[
    - Returns the intersection between an infinite line and a plane.

    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
    planeOrigin: (Vector)
        - The center of the plane.
    planeNormalAng: (Angle or Vector)
        - The normal of the plane.
        - If planeWidth is provided, it's recommended to have this as an Angle.
    planeWidth: (optional) (number)
        - The width of the plane.
        - If nil, will be an infinite plane.
    planeHeight: (optional) (number)
        - The height of the plane.
        - Defaults to the value of planeWidth.
    precision: (optional) (number >= 0)
        - The maximum distance between the line and the plane for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 10^-5.

    RETURNS: intersectionPoint
        intersectionPoint: (Vector or nil)
            - The intersection point of the line and the plane, or nil if they don't intersect.
--]]
function vectorMath.lineIntersectionWithPlane( lineOrigin, lineDir, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision )
    precision = precision or PRECISION_TINY

    local planeNormal
    planeNormal, planeNormalAng = getPlaneNormal( planeNormalAng )

    local dot = lineDir:dot( planeNormal )

    if dot == 0 then
        if not vectorMath.isPointOnPlane( lineOrigin, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision ) then return end

        return lineOrigin:clone()
    end

    local adjacent = vectorMath.pointDistanceFromPlane( lineOrigin, planeOrigin, planeNormal )
    if adjacent == 0 then return lineOrigin:clone() end

    local swapLineDir = true

    if dot < 0 then
        dot = -dot
        swapLineDir = not swapLineDir
    end

    if vectorMath.isPointBelowPlane( lineOrigin, planeOrigin, planeNormal ) then
        swapLineDir = not swapLineDir
    end

    if swapLineDir then
        lineDir = -lineDir
    end

    local hypotenuse = adjacent / dot -- Recall that dot product on unit vectors gives cos(), and that cos() = a / h
    local intersectionPoint = lineOrigin + lineDir * hypotenuse

    if not vectorMath.isPointOnPlane( intersectionPoint, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision ) then return end

    return intersectionPoint
end

--[[
    - Returns the intersection point between a line segment and a plane.

    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
    planeOrigin: (Vector)
        - The center of the plane.
    planeNormalAng: (Angle or Vector)
        - The normal of the plane.
        - If planeWidth is provided, it's recommended to have this as an Angle.
    planeWidth: (optional) (number)
        - The width of the plane.
        - If nil, will be an infinite plane.
    planeHeight: (optional) (number)
        - The height of the plane.
        - Defaults to the value of planeWidth.
    precision: (optional) (number >= 0)
        - The maximum distance between the line segment and the plane for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 0.

    RETURNS: intersectionPoint
        intersectionPoint: (Vector or nil)
            - The intersection point of the line segment and the plane, or nil if they don't intersect.
--]]
function vectorMath.lineSegmentIntersectionWithPlane( segmentStart, segmentEnd, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision )
    local intersectionPoint = vectorMath.lineIntersectionWithPlane( segmentStart, segmentEnd - segmentStart, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision )
    if not intersectionPoint then return end
    if not vectorMath.isPointOnLineSegment( intersectionPoint, segmentStart, segmentEnd, precision ) then return end

    return intersectionPoint
end

--[[
    - Returns the intersection point(s) between an infinite line and a sphere.

    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
    spherePos: (Vector)
        - The center of the sphere.
    radius: (number)
        - The radius of the sphere.
    precision: (optional) (number >= 0)
        - The maximum distance between intersections for them to be considered as just one.
        - Smaller values are more precise.
        - Default is 10^-5.

    RETURNS: intersectionPoint1, intersectionPoint2, delta1, delta2
        intersectionPoint1: (Vector or nil)
            - The first point where the line and sphere intersect, or nil if they don't.
        intersectionPoint2: (Vector or nil)
            - The second point where the line and sphere intersect, or nil if they don't.
            - If there are two intersections, intersectionPoint1 will be the one closest to lineOrigin.
        delta1: (number or nil)
            - The signed distance from lineOrigin to intersectionPoint1 by lineDir.
            - If there is only one intersection, you will receive Vector, nil, number, nil.
        delta2: (number or nil)
            - The signed distance from lineOrigin to intersectionPoint2 by lineDir.
--]]
function vectorMath.lineIntersectionWithSphere( lineOrigin, lineDir, spherePos, radius, precision )
    precision = precision or PRECISION_TINY

    -- Solution from https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
    local diff = lineOrigin - spherePos
    local diffDot = diff:dot( lineDir )
    local separationSqr = diffDot ^ 2 - ( diff:dot( diff ) - radius ^ 2 )

    if separationSqr < 0 then return end -- No intersection

    local separation = mSqrt( separationSqr )
    local delta1 = -diffDot + separation
    local intersectionPoint1 = lineOrigin + lineDir * delta1

    -- One intersection
    if separation <= precision then return intersectionPoint1, nil, delta1 end

    local delta2 = -diffDot - separation
    local intersectionPoint2 = lineOrigin + lineDir * delta2

    -- Two intersections
    if mAbs( delta1 ) <= mAbs( delta2 ) then
        return intersectionPoint1, intersectionPoint2, delta1, delta2
    end

    -- Two intersections, swapped order
    return intersectionPoint2, intersectionPoint1, delta2, delta1
end

--[[
    - Returns the intersection point(s) between a line segment and a sphere.

    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
    spherePos: (Vector)
        - The center of the sphere.
    radius: (number)
        - The radius of the sphere.
    precision: (optional) (number >= 0)
        - The maximum distance between intersections for them to be considered as just one.
        - Smaller values are more precise.
        - Default is 10^-5.

    RETURNS: intersectionPoint1, intersectionPoint2, delta1, delta2
        intersectionPoint1: (Vector or nil)
            - The first point where the line segment and sphere intersect, or nil if they don't.
        intersectionPoint2: (Vector or nil)
            - The second point where the line segment and sphere intersect, or nil if they don't.
            - If there are two intersections, intersectionPoint1 will be the one closest to segmentStart.
        delta1: (number or nil)
            - The signed distance from segmentStart to intersectionPoint1 by segmentDir.
            - If there is only one intersection, you will receive Vector, nil, number, nil.
        delta2: (number or nil)
            - The signed distance from segmentStart to intersectionPoint2 by segmentDir.
--]]
function vectorMath.lineSegmentIntersectionWithSphere( segmentStart, segmentEnd, spherePos, radius, precision )
    precision = precision or PRECISION_TINY

    local segmentDir, segmentLength = vectorMath.getDirectionAndLength( segmentEnd - segmentStart )

    local intersectionPoint1, intersectionPoint2, delta1, delta2 = vectorMath.lineIntersectionWithSphere( segmentStart, segmentDir, spherePos, radius, precision )
    if not intersectionPoint1 then return end

    -- Drop point 2 if it's not on the segment.
    if intersectionPoint2 and ( delta2 < -precision or delta2 > ( segmentLength + precision ) ) then
        intersectionPoint2 = nil
        delta2 = nil
    end

    -- Replace point 1 with point 2 (which may be nil) if point 1 is not on the segment.
    if intersectionPoint1 and ( delta1 < -precision or delta1 > ( segmentLength + precision ) ) then
        intersectionPoint1 = intersectionPoint2
        delta1 = delta2
        intersectionPoint2 = nil
        delta2 = nil
    end

    return intersectionPoint1, intersectionPoint2, delta1, delta2
end

--[[
    - Returns whether or not two vectors are equal, within a given precision.

    vec1: (Vector)
        - The first vector to compare.
    vec2: (Vector)
        - The second vector to compare.
    precision: (optional) (number >= 0)
        - The maximum distance between the vectors for them to be considered equal.
        - Smaller values are more precise.
        - Default is 0.
--]]
function vectorMath.isPointOnPoint( point1, point2, precision )
    if precision then
        return point1:getDistanceSqr( point2 ) <= precision * precision
    end

    return point1 == point2
end

--[[
    - Returns whether or not a point is on an infinite line.

    point: (Vector)
        - The point to check.
    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
    precision: (optional) (number >= 0)
        - The maximum distance between the point and the line for it to be considered on the line.
        - Smaller values are more precise.
        - Default is 0.
--]]
function vectorMath.isPointOnLine( point, lineOrigin, lineDir, precision )
    return vectorMath.pointDistanceFromLine( point, lineOrigin, lineDir ) <= ( precision or 0 )
end

--[[
    - Returns whether or not a point is on a line segment.

    point: (Vector)
        - The point to check.
    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
    precision: (optional) (number >= 0)
        - The maximum distance between the point and the line segment for it to be considered on the line segment.
        - Smaller values are more precise.
        - Default is 0.
--]]
function vectorMath.isPointOnLineSegment( point, segmentStart, segmentEnd, precision )
    return vectorMath.pointDistanceFromLineSegment( point, segmentStart, segmentEnd ) <= ( precision or 0 )
end

--[[
    - Returns whether or not a point is on a plane.

    point: (Vector)
        - The point to check.
    planeOrigin: (Vector)
        - The center of the plane.
    planeNormalAng: (Angle or Vector)
        - The normal of the plane.
        - If planeWidth is provided, it's recommended to have this as an Angle.
    planeWidth: (optional) (number)
        - The width of the plane.
        - If nil, will be an infinite plane.
    planeHeight: (optional) (number)
        - The height of the plane.
        - Defaults to the value of planeWidth.
    precision: (optional) (number >= 0)
        - The maximum distance between the point and the plane for it to be considered on the plane.
        - Smaller values are more precise.
        - Default is 10^-5.
--]]
function vectorMath.isPointOnPlane( point, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision )
    precision = precision or PRECISION_TINY

    local planeNormal
    planeNormal, planeNormalAng = getPlaneNormal( planeNormalAng )

    if not planeWidth and not planeHeight then
        return vectorMath.pointDistanceFromPlane( point, planeOrigin, planeNormal ) <= precision
    end

    local closestPoint = vectorMath.closestPointOnPlane( point, planeOrigin, planeNormalAng, planeWidth, planeHeight )

    return vectorMath.isPointOnPoint( point, closestPoint, precision )
end

--[[
    - Returns whether or not a point is above an infinite plane's normal.

    point: (Vector)
        - The point to check.
    planeOrigin: (Vector)
        - A point on the plane.
    planeNormal: (Vector)
        - The normal of the plane.
--]]
function vectorMath.isPointAbovePlane( point, planeOrigin, planeNormal )
    return ( point - planeOrigin ):dot( planeNormal ) > 0
end

--[[
    - Returns whether or not a point is below an infinite plane's normal.

    point: (Vector)
        - The point to check.
    planeOrigin: (Vector)
        - A point on the plane.
    planeNormal: (Vector)
        - The normal of the plane.
--]]
function vectorMath.isPointBelowPlane( point, planeOrigin, planeNormal )
    return ( point - planeOrigin ):dot( planeNormal ) < 0
end

--[[
    - Returns whether or not two infinite lines intersect.

    lineOrigin1: (Vector)
        - A point on the first line.
    lineDir1: (Vector)
        - The direction of the first line.
    lineOrigin2: (Vector)
        - A point on the second line.
    lineDir2: (Vector)
        - The direction of the second line.
    precision: (optional) (number >= 0)
        - The maximum distance between the lines for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 10^-5.
--]]
function vectorMath.doesLineIntersectWithLine( lineOrigin1, lineDir1, lineOrigin2, lineDir2, precision )
    return vectorMath.lineIntersectionWithLine( lineOrigin1, lineDir1, lineOrigin2, lineDir2, precision ) ~= nil
end

--[[
    - Returns whether or not two line segments intersect.

    segmentStart1: (Vector)
        - The start of the first line segment.
    segmentEnd1: (Vector)
        - The end of the first line segment.
    segmentStart2: (Vector)
        - The start of the second line segment.
    segmentEnd2: (Vector)
        - The end of the second line segment.
    precision: (optional) (number >= 0)
        - The maximum distance between the line segments for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 0.
--]]
function vectorMath.doesLineSegmentIntersectWithLineSegment( segmentStart1, segmentEnd1, segmentStart2, segmentEnd2, precision )
    local segmentDir1, segmentLength1 = vectorMath.getDirectionAndLength( segmentEnd1 - segmentStart1 )
    if segmentLength1 == 0 then return vectorMath.isPointOnLineSegment( segmentStart1, segmentStart2, segmentEnd2, precision ) end

    local segmentDir2, segmentLength2 = vectorMath.getDirectionAndLength( segmentEnd2 - segmentStart2 )
    if segmentLength2 == 0 then return vectorMath.isPointOnLineSegment( segmentStart2, segmentStart1, segmentEnd1, precision ) end

    -- Get infinite line intersection, then check if it's on both line segments
    local intersectionPoint = vectorMath.lineIntersectionWithLine( segmentStart1, segmentDir1, segmentStart2, segmentDir2, precision )
    if not intersectionPoint then return false end

    if not vectorMath.isPointOnLineSegment( intersectionPoint, segmentStart1, segmentEnd1, precision ) then return false end
    if not vectorMath.isPointOnLineSegment( intersectionPoint, segmentStart2, segmentEnd2, precision ) then return false end

    return true
end

--[[
    - Returns whether or not an infinite line intersects a plane.

    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
    planeOrigin: (Vector)
        - The center of the plane.
    planeNormalAng: (Angle or Vector)
        - The normal of the plane.
        - If planeWidth is provided, it's recommended to have this as an Angle.
    planeWidth: (optional) (number)
        - The width of the plane.
        - If nil, will be an infinite plane.
    planeHeight: (optional) (number)
        - The height of the plane.
        - Defaults to the value of planeWidth.
    precision: (optional) (number >= 0)
        - The maximum distance between the line and the plane for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 0.
--]]
function vectorMath.doesLineIntersectWithPlane( lineOrigin, lineDir, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision )
    return vectorMath.lineIntersectionWithPlane( lineOrigin, lineDir, planeOrigin, planeNormalAng, planeWidth, planeHeight, precision ) ~= nil
end

--[[
    - Returns whether or not an infinite line intersects a sphere.

    lineOrigin: (Vector)
        - A point on the line.
    lineDir: (Vector)
        - The direction of the line.
    spherePos: (Vector)
        - The center of the sphere.
    radius: (number)
        - The radius of the sphere.
    precision: (optional) (number >= 0)
        - The maximum distance at the intersection area them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 10^-5.
--]]
function vectorMath.doesLineIntersectWithSphere( lineOrigin, lineDir, spherePos, radius, precision )
    return vectorMath.lineIntersectionWithSphere( lineOrigin, lineDir, spherePos, radius, precision ) ~= nil
end

--[[
    - Returns whether or not a line segment intersects a sphere.

    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
    spherePos: (Vector)
        - The center of the sphere.
    radius: (number)
        - The radius of the sphere.
    precision: (optional) (number >= 0)
        - The maximum distance at the intersection area for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 10^-5.
--]]
function vectorMath.doesLineSegmentIntersectWithSphere( segmentStart, segmentEnd, spherePos, radius, precision )
    return vectorMath.lineSegmentIntersectionWithSphere( segmentStart, segmentEnd, spherePos, radius, precision ) ~= nil
end

--[[
    - Returns whether or not two infinite planes intersect.

    planeOrigin1: (Vector)
        - A point on the first plane.
    planeNormal1: (Vector)
        - The normal of the first plane.
    planeOrigin2: (Vector)
        - A point on the second plane.
    planeNormal2: (Vector)
        - The normal of the second plane.
    precision: (optional) (number >= 0)
        - The maximum distance between the planes for them to be considered intersecting.
        - Smaller values are more precise.
        - Default is 0.
--]]
function vectorMath.doesPlaneIntersectWithPlane( planeOrigin1, planeNormal1, planeOrigin2, planeNormal2, precision )
    if planeNormal1 ~= planeNormal2 and planeNormal1 ~= -planeNormal2 then return true end

    return vectorMath.isPointOnPlane( planeOrigin1, planeOrigin2, planeNormal2, nil, nil, precision )
end

--[[
    - Returns a random point along a line.

    dir: (Vector)
        - The direction of the line.
    maxLength: (optional) (number)
        - The maximum total length of the line, which extends in both directions from the origin.
        - Default is 50000.
--]]
function vectorMath.randomAlongLine( dir, maxLength )
    local radius = ( maxLength or 50000 ) / 2

    return vectorMath.randomAlongLineSegment( dir * -radius, dir * radius )
end

--[[
    - Returns a random point along a line segment.

    segmentStart: (Vector)
        - The start of the line segment.
    segmentEnd: (Vector)
        - The end of the line segment.
--]]
function vectorMath.randomAlongLineSegment( segmentStart, segmentEnd )
    return mLerpVector( mRand( 0, 1 ), segmentStart, segmentEnd )
end

--[[
    - Returns a random point along the circumference of a circle.

    radius: (number)
        - The radius of the circle.
    circleNormal: (optional) (Vector or Angle)
        - The normal of the plane of the circle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a circle on the XY plane.
--]]
function vectorMath.randomAlongCircle( radius, circleNormal )
    local theta = mRand( 0, PI_DOUBLE )
    local x = mCos( theta ) * radius
    local y = mSin( theta ) * radius

    if not circleNormal then return Vector( x, y, 0 ) end

    if type( circleNormal ) == "Vector" then
        circleNormal = circleNormal:getAngle()
    end

    return circleNormal:getUp() * x + circleNormal:getRight() * y
end

--[[
    - Returns a random point inside the area a circle.

    radius: (number)
        - The radius of the circle.
    circleNormal: (optional) (Vector or Angle)
        - The normal of the plane of the circle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a circle on the XY plane.
--]]
function vectorMath.randomInsideCircle( radius, circleNormal )
    return vectorMath.randomAlongCircle( radius * mRand( 0, 1 ), circleNormal )
end

--[[
    - Returns a random point inside the area between two circles with the same center.

    minRadius: (number)
        - The minimum radius of the circle.
    maxRadius: (number)
        - The maximum radius of the circle.
    circleNormal: (optional) (Vector or Angle)
        - The normal of the plane of the circle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a circle on the XY plane.
--]]
function vectorMath.randomInsideBoundedCircle( minRadius, maxRadius, circleNormal )
    return vectorMath.randomAlongCircle( mRand( minRadius, maxRadius ), circleNormal )
end

--[[
    - Returns whether or not an x, y point is within the area of a circle.
    - This is purely 2D, hence the lack of a z parameter or any vectors.

    x: (number)
        - The x position of the point.
    y: (number)
        - The y position of the point.
    circleX: (number)
        - The x position of the circle's center.
    circleY: (number)
        - The y position of the circle's center.
    radius: (number)
        - The radius of the circle.
--]]
function vectorMath.isXYWithinCircle( x, y, circleX, circleY, radius )
    x = x - circleX
    y = y - circleY

    return x * x + y * y <= radius * radius
end

--[[
    - Returns a random point along the surface area of a sphere.

    radius: (number)
        - The radius of the sphere.
--]]
function vectorMath.randomAlongSphere( radius )
    local theta = mRand( 0, PI_DOUBLE )
    local phi = mRand( 0, PI_DOUBLE )

    local sinPhi = mSin( phi )

    local x = mCos( theta ) * sinPhi * radius
    local y = mSin( theta ) * sinPhi * radius
    local z = mCos( phi ) * radius

    return Vector( x, y, z )
end

--[[
    - Returns a random point inside the volume of a sphere.

    radius: (number)
        - The radius of the sphere.
--]]
function vectorMath.randomInsideSphere( radius )
    return vectorMath.randomAlongSphere( radius * mRand( 0, 1 ) )
end

--[[
    - Returns a random point inside the volume of two spheres with the same center.

    minRadius: (number)
        - The minimum radius of the sphere.
    maxRadius: (number)
        - The maximum radius of the sphere.
--]]
function vectorMath.randomInsideBoundedSphere( minRadius, maxRadius )
    return vectorMath.randomAlongSphere( mRand( minRadius, maxRadius ) )
end

--[[
    - Returns whether or not a point is inside a sphere.

    point: (Vector)
        - The position of the point.
    spherePos: (Vector)
        - The position of the sphere.
    radius: (number)
        - The radius of the sphere.
--]]
function vectorMath.isPointWithinSphere( point, spherePos, radius )
    local diff = point - spherePos

    return diff:getLengthSqr() <= radius * radius
end

--[[
    - Returns whether or not a point is inside a sphere with radius r = sqrt( radiusSqr ).
    - Slightly more efficient than vectorMath.isPointWithinSphere() when radiusSqr is pre-calculated.

    point: (Vector)
        - The position of the point.
    spherePos: (Vector)
        - The position of the sphere.
    radiusSqr: (number)
        - The square of the radius of the sphere.
--]]
function vectorMath.isPointWithinSphereSqr( point, spherePos, radiusSqr )
    local diff = point - spherePos

    return diff:getLengthSqr() <= radiusSqr
end

--[[
    - Clamps a point to be along the surface area of a sphere.

    point: (Vector)
        - The point to clamp.
    spherePos: (Vector)
        - The position of the sphere.
    radius: (number)
        - The radius of the sphere.
    fallbackPoint: (optional) (Vector)
        - A fallback return value for if a reasonable result couldn't be determined.
        - This occurs when point == spherePos.
--]]
function vectorMath.clampAlongSphere( point, spherePos, radius, fallbackPoint )
    local originToPoint = point - spherePos
    local distSqr = originToPoint:getLengthSqr()
    if distSqr == 0 then return fallbackPoint or ( spherePos + vectorMath.randomAlongSphere( radius ) ) end

    local dist = mSqrt( distSqr )
    local originToPointDir = originToPoint / dist

    return spherePos + originToPointDir * radius
end

--[[
    - Clamps a point to be inside the volume of a sphere.

    point: (Vector)
        - The point to clamp.
    spherePos: (Vector)
        - The position of the sphere.
    radius: (number)
        - The radius of the sphere.
--]]
function vectorMath.clampInsideSphere( point, spherePos, radius )
    local originToPoint = point - spherePos
    local distSqr = originToPoint:getLengthSqr()
    if distSqr == 0 then return point:clone() end
    if distSqr < radius * radius then return point:clone() end

    local dist = mSqrt( distSqr )
    local originToPointDir = originToPoint / dist

    return spherePos + originToPointDir * radius
end

--[[
    - Clamps a point to be outside the volume of a sphere.

    point: (Vector)
        - The point to clamp.
    spherePos: (Vector)
        - The position of the sphere.
    radius: (number)
        - The radius of the sphere.
    fallbackPoint: (optional) (Vector)
        - A fallback return value for if a reasonable result couldn't be determined.
        - This occurs when point == spherePos.
--]]
function vectorMath.clampOutsideSphere( point, spherePos, radius, fallbackPoint )
    local originToPoint = point - spherePos
    local distSqr = originToPoint:getLengthSqr()
    if distSqr == 0 then return fallbackPoint or ( spherePos + vectorMath.randomAlongSphere( radius ) ) end
    if distSqr > radius * radius then return point:clone() end

    local dist = mSqrt( distSqr )
    local originToPointDir = originToPoint / dist

    return spherePos + originToPointDir * radius
end

--[[
    - Returns a random point along the surface area of a tube (a cylinder with no end caps).

    radius: (number)
        - The radius of the tube.
    length: (number)
        - The length of the tube.
    dir: (optional) (Vector or Angle)
        - The direction of the tube's length.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a tube along the Z axis.
    originIsBottom: (optional) (boolean)
        - Whether (0,0,0) is considered to be the bottom of the tube, rather than its center.
        - Default is false.
--]]
function vectorMath.randomAlongTube( radius, length, dir, originIsBottom )
    local theta = mRand( 0, PI_DOUBLE )
    local x = mCos( theta ) * radius
    local y = mSin( theta ) * radius
    local lengthEff

    if originIsBottom then
        lengthEff = length * mRand( 0, 1 )
    else
        lengthEff = length * mRand( -0.5, 0.5 )
    end

    if not dir then return Vector( x, y, lengthEff ) end

    if type( dir ) == "Vector" then
        dir = dir:getAngle()
    end

    return dir:getUp() * x + dir:getRight() * y + dir:getForward() * lengthEff
end

--[[
    - Returns a random point along the surface area of a cylinder, including its end caps.

    radius: (number)
        - The radius of the cylinder.
    length: (number)
        - The length of the cylinder.
    dir: (optional) (Vector or Angle)
        - The direction of the cylinder's length.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a cylinder along the Z axis.
    originIsBottom: (optional) (boolean)
        - Whether (0,0,0) is considered to be the bottom of the cylinder, rather than its center.
        - Default is false.
--]]
function vectorMath.randomAlongCylinder( radius, length, dir, originIsBottom )
    if radius == 0 or length == 0 then return Vector( 0, 0, 0 ) end

    -- Adjust chance based on surface area so every point has equal chance.
    local circumference = PI_DOUBLE * radius
    local combinedCircleArea = PI_DOUBLE * radius * radius
    local tubeArea = circumference * length
    local totalArea = combinedCircleArea + tubeArea

    -- Random point on the tube
    if mRand( 0, 1 ) <= tubeArea / totalArea then
        return vectorMath.randomAlongTube( radius, length, dir, originIsBottom )
    end

    -- Random point on an end cap
    local useTop = mRandom( 1, 2 ) == 1
    local cylinderBottom, dirEff = getCylinderBottomAndDirEff( length, dir, originIsBottom )
    local circlePos = cylinderBottom

    if useTop then
        circlePos = circlePos + dirEff * length
    end

    return circlePos + vectorMath.randomInsideCircle( radius, dir )
end

--[[
    - Returns a random point along the edges (i.e. top and bottom circle circumferences) of a cylinder.

    radius: (number)
        - The radius of the cylinder.
    length: (number)
        - The length of the cylinder.
    dir: (optional) (Vector or Angle)
        - The direction of the cylinder's length.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a cylinder along the Z axis.
    originIsBottom: (optional) (boolean)
        - Whether (0,0,0) is considered to be the bottom of the cylinder, rather than its center.
        - Default is false.
--]]
function vectorMath.randomAlongCylinderEdges( radius, length, dir, originIsBottom )
    local cylinderBottom, dirEff = getCylinderBottomAndDirEff( length, dir, originIsBottom )
    local useBottom = mRandom( 1, 2 ) == 1
    local circlePos = useBottom and cylinderBottom or cylinderBottom + dirEff * length

    return circlePos + vectorMath.randomAlongCircle( radius, dir )
end

--[[
    - Returns a random point inside the volume of a cylinder.

    radius: (number)
        - The radius of the cylinder.
    length: (number)
        - The length of the cylinder.
    dir: (optional) (Vector or Angle)
        - The direction of the cylinder's length.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a cylinder along the Z axis.
    originIsBottom: (optional) (boolean)
        - Whether (0,0,0) is considered to be the bottom of the cylinder, rather than its center.
        - Default is false.
--]]
function vectorMath.randomInsideCylinder( radius, length, dir, originIsBottom )
    local cylinderBottom, dirEff = getCylinderBottomAndDirEff( length, dir, originIsBottom )
    local circlePos = cylinderBottom + dirEff * mRand( 0, length )

    return circlePos + vectorMath.randomInsideCircle( radius, dir )
end

--[[
    - Returns a random point inside the volume of two cylinders with the same center/bottom (depending on originIsBottom).

    minRadius: (number)
        - The minimum radius of the cylinder.
    maxRadius: (number)
        - The maximum radius of the cylinder.
    minLength: (number)
        - The minimum length of the cylinder.
    maxLength: (number)
        - The maximum length of the cylinder.
    dir: (optional) (Vector or Angle)
        - The direction of the cylinder's length.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a cylinder along the Z axis.
    originIsBottom: (optional) (boolean)
        - Whether (0,0,0) is considered to be the bottom of the cylinder, rather than its center.
        - Default is false.
        - Note that, if this is true, the entire min/max length range will consist of cylinders with their bottom at (0,0,0).
            - i.e. the cylinders will scale by the bottom, and not by their centers, unlike with other 'randomInside____' functions.
--]]
function vectorMath.randomInsideBoundedCylinder( minRadius, maxRadius, minLength, maxLength, dir, originIsBottom )
    return vectorMath.randomAlongTube( mRand( minRadius, maxRadius ), mRand( minLength, maxLength ), dir, originIsBottom )
end

--[[
    - Returns whether or not a point is inside a cylinder.

    point: (Vector)
        - The position of the point.
    cylinderPos: (Vector)
        - The position of the cylinder.
        - This is either the center (false) or the bottom (true) of the cylinder, depending on the value of originIsBottom.
    radius: (number)
        - The radius of the cylinder.
    length: (number)
        - The length of the cylinder.
    dir: (optional) (Vector or Angle)
        - The direction of the cylinder's length.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a cylinder along the Z axis.
    originIsBottom: (optional) (boolean)
        - Whether cylinderPos is considered to be the bottom of the cylinder, rather than its center.
        - Default is false.
--]]
function vectorMath.isPointWithinCylinder( point, cylinderPos, radius, length, dir, originIsBottom )
    local cylinderBottom, dirEff = getCylinderBottomAndDirEff( length, dir, originIsBottom )
    cylinderBottom = cylinderBottom + cylinderPos

    if not dir then
        local zDiff = point[3] - cylinderBottom[3]
        if zDiff < 0 or zDiff > length then return false end

        return vectorMath.isXYWithinCircle( point[1], point[2], cylinderBottom[1], cylinderBottom[2], radius )
    end

    local pointToBottom = cylinderBottom - point
    if pointToBottom:dot( dirEff ) > 0 then return false end

    local pointToTop = pointToBottom + dirEff * length
    if pointToTop:dot( dirEff ) < 0 then return false end

    return vectorMath.isPointOnLine( point, cylinderBottom, dirEff, radius )
end

--[[
    - Returns a random point along the surface area of a cone, excluding its base.

    tip: (Vector)
        - The narrow end of the cone.
    dir: (Vector)
        - The direction of the cone's length.
        - This points from the tip to the base.
    length: (number)
        - The length of the cone.
    endRadius: (number or nil)
        - The radius of the base of the cone.
        - If nil, you must specify theta.
    theta: ( 0 <= number < PI / 2 or nil)
        - The angle between the tip, base center, and base rim of the circle, measured in radians.
        - If nil, you must specify endRadius.
--]]
function vectorMath.randomAlongConeWithoutBase( tip, dir, length, endRadius, theta )
    endRadius = getConeEndRadius( length, endRadius, theta )

    local frac = mRand( 0, 1 )

    return tip + dir * length * frac + vectorMath.randomAlongCircle( endRadius * frac, dir )
end

--[[
    - Returns a random point along the surface area of a cone.

    tip: (Vector)
        - The narrow end of the cone.
    dir: (Vector)
        - The direction of the cone's length.
        - This points from the tip to the base.
    length: (number)
        - The length of the cone.
    endRadius: (number or nil)
        - The radius of the base of the cone.
        - If nil, you must specify theta.
    theta: ( 0 <= number < PI / 2 or nil)
        - The angle between the tip, base center, and base rim of the circle, measured in radians.
        - If nil, you must specify endRadius.
--]]
function vectorMath.randomAlongCone( tip, dir, length, endRadius, theta )
    endRadius = getConeEndRadius( length, endRadius, theta )

    local endRadiusSqr = endRadius * endRadius
    local slantLength = mSqrt( length * length + endRadiusSqr )

    local circleArea = PI * endRadiusSqr
    local slantArea = PI * endRadius * slantLength
    local totalArea = circleArea + slantArea

    -- Random point on base
    if mRand( 0, 1 ) <= circleArea / totalArea then
        return tip + dir * length + vectorMath.randomInsideCircle( endRadius, dir )
    end

    -- Random point on slant
    local frac = mRand( 0, 1 )

    return tip + dir * length * frac + vectorMath.randomAlongCircle( endRadius * frac, dir )
end

--[[
    - Returns a random point inside the volume of a cone.

    tip: (Vector)
        - The narrow end of the cone.
    dir: (Vector)
        - The direction of the cone's length.
        - This points from the tip to the base.
    length: (number)
        - The length of the cone.
    endRadius: (number or nil)
        - The radius of the base of the cone.
        - If nil, you must specify theta.
    theta: ( 0 <= number < PI / 2 or nil)
        - The angle between the tip, base center, and base rim of the circle, measured in radians.
        - If nil, you must specify endRadius.
--]]
function vectorMath.randomInsideCone( tip, dir, length, endRadius, theta )
    endRadius = getConeEndRadius( length, endRadius, theta )

    local frac = mRand( 0, 1 )

    return tip + dir * length * frac + vectorMath.randomInsideCircle( endRadius * frac, dir )
end

--[[
    - Returns a random point inside the volume of two cones with the same tip.

    tip: (Vector)
        - The narrow end of the cone.
    dir: (Vector)
        - The direction of the cone's length.
        - This points from the tip to the base.
    minLength: (number)
        - The minimum length of the cone.
    maxLength: (number)
        - The maximum length of the cone.
    minEndRadius: (number or nil)
        - The minimum radius of the base of the cone.
        - If nil, you must specify minTheta and maxTheta.
    maxEndRadius: (number or nil)
        - The maximum radius of the base of the cone.
        - If nil, you must specify minTheta and maxTheta.
    minTheta: ( 0 <= number < PI / 2 or nil)
        - The minimum angle between the tip, base center, and base rim of the circle, measured in radians.
        - If nil, you must specify minEndRadius and maxEndRadius.
    maxTheta: ( 0 <= number < PI / 2 or nil)
        - The maximum angle between the tip, base center, and base rim of the circle, measured in radians.
        - If nil, you must specify minEndRadius and maxEndRadius.
--]]
function vectorMath.randomInsideBoundedCone( tip, dir, minLength, maxLength, minEndRadius, maxEndRadius, minTheta, maxTheta )
    local length = mRand( minLength, maxLength )
    local endRadius = minEndRadius and maxEndRadius and mRand( minEndRadius, maxEndRadius )
    local theta = minTheta and maxTheta and mRand( minTheta, maxTheta )

    return vectorMath.randomInsideCone( tip, dir, length, endRadius, theta )
end

function vectorMath.isPointWithinCone( point, coneTip, dir, length, endRadius, theta )
    local tipToPoint = point - coneTip
    local tipToPointDir, tipToPointLength = vectorMath.getDirectionAndLength( tipToPoint )
    if tipToPointLength == 0 then return true end

    local dot = tipToPointDir:dot( dir )
    if dot <= 0 then return false end
    if tipToPointLength * dot > length then return false end -- Account for flat end of cone by getting projected length of point onto dir.

    endRadius = getConeEndRadius( length, endRadius, theta )
    theta = mATan( endRadius / length )

    local pointAng = mACos( dot )
    if pointAng > theta then return false end

    return pointAng <= theta
end

function vectorMath.isPointWithinRoundedCone( point, coneTip, dir, length, endRadius, theta )
    local tipToPoint = point - coneTip
    local tipToPointDir, tipToPointLength = vectorMath.getDirectionAndLength( tipToPoint )
    if tipToPointLength == 0 then return true end
    if tipToPointLength > length then return false end

    local dot = tipToPointDir:dot( dir )
    if dot <= 0 then return false end

    endRadius = getConeEndRadius( length, endRadius, theta )
    theta = mATan( endRadius / length )

    local pointAng = mACos( dot )

    return pointAng <= theta
end

--[[
    - Returns a random point along the perimeter of a rectangle.

    width: (number)
        - The width of the rectangle.
    height: (number)
        - The height of the rectangle.
    rectNormal: (optional) (Vector or Angle)
        - The normal of the plane of the rectangle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a rectangle on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomAlongRectangle( width, height, rectNormal, originIsTopLeft )
    local x
    local y

    if mRandom( 1, 2 ) == 1 then
        x = mRand( 0, width )
        y = mRandom( 1, 2 ) == 1 and 0 or height
    else
        x = mRandom( 1, 2 ) == 1 and 0 or width
        y = mRand( 0, height )
    end

    if not originIsTopLeft then
        x = x - width * 0.5
        y = y - height * 0.5
    end

    if not rectNormal then return Vector( y, x, 0 ) end

    if type( rectNormal ) == "Vector" then
        rectNormal = rectNormal:getAngle()
    end

    return -rectNormal:getRight() * x - rectNormal:getUp() * y
end

--[[
    - Returns a random point on the corners of a rectangle.

    width: (number)
        - The width of the rectangle.
    height: (number)
        - The height of the rectangle.
    rectNormal: (optional) (Vector or Angle)
        - The normal of the plane of the rectangle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a rectangle on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomAlongRectangleCorners( width, height, rectNormal, originIsTopLeft )
    local x = mRandom( 1, 2 ) == 1 and 0 or width
    local y = mRandom( 1, 2 ) == 1 and 0 or height

    if not originIsTopLeft then
        x = x - width * 0.5
        y = y - height * 0.5
    end

    if not rectNormal then return Vector( y, x, 0 ) end

    if type( rectNormal ) == "Vector" then
        rectNormal = rectNormal:getAngle()
    end

    return -rectNormal:getRight() * x - rectNormal:getUp() * y
end

--[[
    - Returns a random point inside the area of a rectangle.

    width: (number)
        - The width of the rectangle.
    height: (number)
        - The height of the rectangle.
    rectNormal: (optional) (Vector or Angle)
        - The normal of the plane of the rectangle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a rectangle on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomInsideRectangle( width, height, rectNormal, originIsTopLeft )
    local x = mRand( 0, width )
    local y = mRand( 0, height )

    if not originIsTopLeft then
        x = x - width * 0.5
        y = y - height * 0.5
    end

    if not rectNormal then return Vector( y, x, 0 ) end

    if type( rectNormal ) == "Vector" then
        rectNormal = rectNormal:getAngle()
    end

    return -rectNormal:getRight() * x - rectNormal:getUp() * y
end

--[[
    - Returns a random point inside the area between two rectangles with the same center/top left (depenging on originIsTopLeft).

    minWidth: (number)
        - The minimum width of the rectangle.
    maxWidth: (number)
        - The maximum width of the rectangle.
    minHeight: (number)
        - The minimum height of the rectangle.
    maxHeight: (number)
        - The maximum height of the rectangle.
    rectNormal: (optional) (Vector or Angle)
        - The normal of the plane of the rectangle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a rectangle on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomInsideBoundedRectangle( minWidth, maxWidth, minHeight, maxHeight, rectNormal, originIsTopLeft )
    return vectorMath.randomAlongRectangle( mRand( minWidth, maxWidth ), mRand( minHeight, maxHeight ), rectNormal, originIsTopLeft )
end

--[[
    - Returns the four points of a rectangle, in clockwise order.

    width: (number)
        - The width of the rectangle.
    height: (number)
        - The height of the rectangle.
    rectNormal: (optional) (Vector or Angle)
        - The normal of the plane of the rectangle.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a rectangle on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.getRectangleCorners( width, height, rectNormal, originIsTopLeft )
    local topLeftX = 0
    local topLeftY = 0

    if not originIsTopLeft then
        topLeftX = topLeftX - width * 0.5
        topLeftY = topLeftY - height * 0.5
    end

    if not rectNormal then
        return {
            Vector( topLeftY, topLeftX, 0 ), -- Top left
            Vector( topLeftY, topLeftX + width, 0 ), -- Top right
            Vector( topLeftY + height, topLeftX + width, 0 ), -- Bottom right
            Vector( topLeftY + height, topLeftX, 0 ), -- Bottom left
        }
    end

    if type( rectNormal ) == "Vector" then
        rectNormal = rectNormal:getAngle()
    end

    local rightDir = -rectNormal:getRight()
    local downDir = -rectNormal:getUp()

    return {
        rightDir * topLeftX + downDir * topLeftY, -- Top left
        rightDir * ( topLeftX + width ) + downDir * topLeftY, -- Top right
        rightDir * ( topLeftX + width ) + downDir * ( topLeftY + height ), -- Bottom right
        rightDir * topLeftX + downDir * ( topLeftY + height ), -- Bottom left
    }
end

--[[
    - Takes two opposing corners and returns the center, width, height, normal of the rectangle they define.

    corner1: (Vector)
        - One of the corners of the rectangle.
    corner2: (Vector)
        - The opposing corner of the rectangle.
    rectNormal: (optional) (Vector)
        - The normal of the plane of the rectangle.
        - Defaults to the normal of a vertical rectangle based on the two corners (normal will be horizontal).
--]]
function vectorMath.getRectangle( corner1, corner2, rectNormal )
    local center = ( corner1 + corner2 ) * 0.5
    local corner1To2 = corner2 - corner1

    rectNormal = rectNormal and rectNormal:clone() or corner1To2:getAngle():getRight()

    local rectNormalAng = rectNormal:getAngle()
    local rectLeft = rectNormalAng:getRight()
    local rectUp = rectNormalAng:getUp()

    local width = mAbs( corner1To2:dot( rectLeft ) )
    local height = mAbs( corner1To2:dot( rectUp ) )

    return center, width, height, rectNormal
end

--[[
    - Returns whether or not an x, y point is within the area of a rectangle.
    - This is purely 2D, hence the lack of a z parameter or any vectors.

    x: (number)
        - The x position of the point.
    y: (number)
        - The y position of the point.
    rectX: (number)
        - The x position of the rectangle.
    rectY: (number)
        - The y position of the rectangle.
    width: (number)
        - The width of the rectangle.
    height: (number)
        - The height of the rectangle.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0) is considered to be the top left of the rectangle, rather than its center.
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.isXYWithinRectangle( x, y, rectX, rectY, width, height, originIsTopLeft )
    if originIsTopLeft then
        return x >= rectX and x <= rectX + width and y >= rectY and y <= rectY + height
    end

    local halfWidth = width * 0.5
    local halfHeight = height * 0.5

    return x >= rectX - halfWidth and x <= rectX + halfWidth and y >= rectY - halfHeight and y <= rectY + halfHeight
end

--[[
    - Returns a random point along the perimeter of a square.

    size: (number)
        - The size of the square.
    squareNormal: (optional) (Vector or Angle)
        - The normal of the plane of the square.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a square on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing squareNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomAlongSquare( size, squareNormal, originIsTopLeft )
    return vectorMath.randomAlongRectangle( size, size, squareNormal, originIsTopLeft )
end

--[[
    - Returns a random point on the corners of a square.

    size: (number)
        - The size of the square.
    squareNormal: (optional) (Vector or Angle)
        - The normal of the plane of the square.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a square on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomAlongSquareCorners( size, squareNormal, originIsTopLeft )
    return vectorMath.randomAlongRectangleCorners( size, size, squareNormal, originIsTopLeft )
end

--[[
    - Returns a random point inside the area of a square.

    size: (number)
        - The size of the square.
    squareNormal: (optional) (Vector or Angle)
        - The normal of the plane of the square.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a square on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing rectNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomInsideSquare( size, squareNormal, originIsTopLeft )
    return vectorMath.randomInsideRectangle( size, size, squareNormal, originIsTopLeft )
end

--[[
    - Returns a random point inside the area between two squares with the same center/top left (depenging on originIsTopLeft).

    minSize: (number)
        - The minimum size of the square.
    maxSize: (number)
        - The maximum size of the square.
    squareNormal: (optional) (Vector or Angle)
        - The normal of the plane of the square.
        - Default is equivalent to (though faster than) Vector( 0, 0, 1 ), which results in a square on the XY plane.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0) is considered to be the top left of the rectangle, rather than its center.
        - This is the top left from the perspective of someone looking at the rectangle (eyes opposing squareNormal).
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.randomInsideBoundedSquare( minSize, maxSize, squareNormal, originIsTopLeft )
    return vectorMath.randomInsideBoundedRectangle( minSize, maxSize, minSize, maxSize, squareNormal, originIsTopLeft )
end

--[[
    - Returns whether or not an x, y point is within the area of a square.
    - This is purely 2D, hence the lack of a z parameter or any vectors.

    x: (number)
        - The x position of the point.
    y: (number)
        - The y position of the point.
    squareX: (number)
        - The x position of the square.
    squareY: (number)
        - The y position of the square.
    size: (number)
        - The size of the square.
    originIsTopLeft: (optional) (boolean)
        - Whether (0,0) is considered to be the top left of the square, rather than its center.
        - Default is false.
        - It's recommended to pass this as true when being used for any rendering/vgui functions.
--]]
function vectorMath.isXYWithinSquare( x, y, squareX, squareY, size, originIsTopLeft )
    return vectorMath.isXYWithinRectangle( x, y, squareX, squareY, size, size, originIsTopLeft )
end

--[[
    - Returns a random point along the surface area of a box.

    minBounds: (Vector)
        - The minimum point of the box.
    maxBounds: (Vector)
        - The maximum point of the box.
--]]
function vectorMath.randomAlongBox( minBounds, maxBounds )
    local restrictedAxis = mRandom( 1, 3 )
    local x
    local y
    local z

    if restrictedAxis == 1 then
        x = mRandom( 1, 2 ) == 1 and minBounds[1] or maxBounds[1]
        y = mRand( minBounds[2], maxBounds[2] )
        z = mRand( minBounds[3], maxBounds[3] )
    elseif restrictedAxis == 2 then
        x = mRand( minBounds[1], maxBounds[1] )
        y = mRandom( 1, 2 ) == 1 and minBounds[2] or maxBounds[2]
        z = mRand( minBounds[3], maxBounds[3] )
    else -- restrictedAxis == 3
        x = mRand( minBounds[1], maxBounds[1] )
        y = mRand( minBounds[2], maxBounds[2] )
        z = mRandom( 1, 2 ) == 1 and minBounds[3] or maxBounds[3]
    end

    return Vector( x, y, z )
end

--[[
    - Returns a random point along the edges of a box.

    minBounds: (Vector)
        - The minimum point of the box.
    maxBounds: (Vector)
        - The maximum point of the box.
--]]
function vectorMath.randomAlongBoxEdges( minBounds, maxBounds )
    local freeAxis = mRandom( 1, 3 )
    local x
    local y
    local z

    if freeAxis == 1 then
        x = mRand( minBounds[1], maxBounds[1] )
        y = mRandom( 1, 2 ) == 1 and minBounds[2] or maxBounds[2]
        z = mRandom( 1, 2 ) == 1 and minBounds[3] or maxBounds[3]
    elseif freeAxis == 2 then
        x = mRandom( 1, 2 ) == 1 and minBounds[1] or maxBounds[1]
        y = mRand( minBounds[2], maxBounds[2] )
        z = mRandom( 1, 2 ) == 1 and minBounds[3] or maxBounds[3]
    else -- freeAxis == 3
        x = mRandom( 1, 2 ) == 1 and minBounds[1] or maxBounds[1]
        y = mRandom( 1, 2 ) == 1 and minBounds[2] or maxBounds[2]
        z = mRand( minBounds[3], maxBounds[3] )
    end

    return Vector( x, y, z )
end

--[[
    - Returns a random point on one of the vertices of a box.

    minBounds: (Vector)
        - The minimum point of the box.
    maxBounds: (Vector)
        - The maximum point of the box.
--]]
function vectorMath.randomAlongBoxVertices( minBounds, maxBounds )
    local x = mRandom( 1, 2 ) == 1 and minBounds[1] or maxBounds[1]
    local y = mRandom( 1, 2 ) == 1 and minBounds[2] or maxBounds[2]
    local z = mRandom( 1, 2 ) == 1 and minBounds[3] or maxBounds[3]

    return Vector( x, y, z )
end

--[[
    - Returns a random point inside the volume of a box.

    minBounds: (Vector)
        - The minimum point of the box.
    maxBounds: (Vector)
        - The maximum point of the box.
--]]
function vectorMath.randomInsideBox( minBounds, maxBounds )
    local x = mRand( minBounds[1], maxBounds[1] )
    local y = mRand( minBounds[2], maxBounds[2] )
    local z = mRand( minBounds[3], maxBounds[3] )

    return Vector( x, y, z )
end

--[[
    - Returns a random point inside the volume between two boxes.

    innerMinBounds: (Vector)
        - The minimum point of the inner box.
    innerMaxBounds: (Vector)
        - The maximum point of the inner box.
    outerMinBounds: (Vector)
        - The minimum point of the outer box.
    outerMaxBounds: (Vector)
        - The maximum point of the outer box.
--]]
function vectorMath.randomInsideBoundedBox( innerMinBounds, innerMaxBounds, outerMinBounds, outerMaxBounds )
    local frac = mRand( 0, 1 )
    local minBounds = mLerpVector( frac, innerMinBounds, outerMinBounds )
    local maxBounds = mLerpVector( frac, innerMaxBounds, outerMaxBounds )

    return vectorMath.randomAlongBox( minBounds, maxBounds )
end

--[[
    - Returns whether or not a point is inside a box.
    - This is only here for the sake of completeness/consistency, as starfall already has Vector:withinAABox().

    point: (Vector)
        - The position of the point.
    minBounds: (Vector)
        - The minimum point of the box.
    maxBounds: (Vector)
        - The maximum point of the box.
--]]
function vectorMath.isPointWithinBox( point, minBounds, maxBounds )
    return point:withinAABox( minBounds, maxBounds )
end

--[[
    - Returns two vectors: the min and max bounds of an axis-aligned box which contails all the input vectors.
    - The vectors can either be given as individual arguments or one single sequential table of vectors.
--]]
function vectorMath.getBoxBounds( ... )
    local args = getArgsAsTable( ... )
    local argCount = #args

    if argCount == 0 then return end

    local arg1 = args[1]

    if argCount == 1 then return arg1:clone(), arg1:clone() end

    local xMin = arg1[1]
    local yMin = arg1[2]
    local zMin = arg1[3]
    local xMax = xMin
    local yMax = yMin
    local zMax = zMin

    for i = 2, argCount do
        local vec = args[i]
        local x = vec[1]
        local y = vec[2]
        local z = vec[3]

        if x < xMin then xMin = x
        elseif x > xMax then xMax = x end

        if y < yMin then yMin = y
        elseif y > yMax then yMax = y end

        if z < zMin then zMin = z
        elseif z > zMax then zMax = z end
    end

    return Vector( xMin, yMin, zMin ), Vector( xMax, yMax, zMax )
end

--[[
    - Returns a table of convexes which make up a hollow box.
    - For use with prop.createCustom().

    width: (number > 0)
        - The inner width of the box.
    height: (number > 0)
        - The inner height of the box.
    thickness: (number > 0)
        - The thickness of the box's walls, extending outwards.
    originMode: (optional) (0, 1, or 2)
        - Determines where the origin will be placed.
        - 0: The origin will be placed at the center of the box. (default)
        - 1: The origin will be placed at the outer bottom of the box.
        - 2: The origin will be placed at the inner bottom of the box.
--]]
function vectorMath.getHollowBoxConvexes( width, height, thickness, originMode )
    local w = width / 2
    local h = height / 2
    local t = thickness
    local ho = 0

    if originMode == 1 then
        ho = h + t
    elseif originMode == 2 then
        ho = h
    end

    return {
        vectorMath.getBoxPoints(
            Vector( -w - t, -w - t, -h - t + ho ), Vector( w + t, -w, h + t + ho )
        ),
        vectorMath.getBoxPoints(
            Vector( -w - t, w, -h - t + ho ), Vector( w + t, w + t, h + t + ho )
        ),

        vectorMath.getBoxPoints(
            Vector( -w - t, -w, -h - t + ho ), Vector( -w, w, h + t + ho )
        ),
        vectorMath.getBoxPoints(
            Vector( w, -w, -h - t + ho ), Vector( w + t, w, h + t + ho )
        ),

        vectorMath.getBoxPoints(
            Vector( -w, -w, -h - t + ho ), Vector( w, w, -h + ho )
        ),
        vectorMath.getBoxPoints(
            Vector( -w, -w, h + ho ), Vector( w, w, h + t + ho )
        ),
    }
end

--[[
    - Returns a list of the 8 points which make up a box.

    minBounds: (Vector)
        - The minimum point of the box.
    maxBounds: (Vector)
        - The maximum point of the box.
--]]
function vectorMath.getBoxPoints( minBounds, maxBounds )
    local minX = minBounds[1]
    local minY = minBounds[2]
    local minZ = minBounds[3]

    local maxX = maxBounds[1]
    local maxY = maxBounds[2]
    local maxZ = maxBounds[3]

    return {
        Vector( minX, minY, minZ ),
        Vector( minX, minY, maxZ ),
        Vector( minX, maxY, minZ ),
        Vector( minX, maxY, maxZ ),
        Vector( maxX, minY, minZ ),
        Vector( maxX, minY, maxZ ),
        Vector( maxX, maxY, minZ ),
        Vector( maxX, maxY, maxZ )
    }
end

--[[
    - Returns the min and max points of a cube with the given side length.

    sideLength: (number)
        - The length of each side of the cube.
--]]
function vectorMath.getCubeBounds( sideLength )
    local sideLengthHalf = sideLength * 0.5
    local minusSideLengthHalf = -sideLengthHalf
    local minBounds = Vector( minusSideLengthHalf, minusSideLengthHalf, minusSideLengthHalf )
    local maxBounds = Vector( sideLengthHalf, sideLengthHalf, sideLengthHalf )

    return minBounds, maxBounds
end

--[[
    - Returns a random point along the surface area of a cube.

    sideLength: (number)
        - The length of each side of the cube.
--]]
function vectorMath.randomAlongCube( sideLength )
    return vectorMath.randomAlongBox( vectorMath.getCubeBounds( sideLength ) )
end

--[[
    - Returns a random point along the edges of a cube.

    sideLength: (number)
        - The length of each side of the cube.
--]]
function vectorMath.randomAlongCubeEdges( sideLength )
    return vectorMath.randomAlongBoxEdges( vectorMath.getCubeBounds( sideLength ) )
end

--[[
    - Returns a random point on one of the vertices of a cube.

    sideLength: (number)
        - The length of each side of the cube.
--]]
function vectorMath.randomAlongCubeVertices( sideLength )
    return vectorMath.randomAlongBoxVertices( vectorMath.getCubeBounds( sideLength ) )
end

--[[
    - Returns a random point inside the volume of a cube.

    sideLength: (number)
        - The length of each side of the cube.
--]]
function vectorMath.randomInsideCube( sideLength )
    return vectorMath.randomInsideBox( vectorMath.getCubeBounds( sideLength ) )
end

--[[
    - Returns a random point inside the volume of two cubes with the same center.
--]]
function vectorMath.randomInsideBoundedCube( minSideLength, maxSideLength )
    return vectorMath.randomAlongCube( mRand( minSideLength, maxSideLength ) )
end

--[[
    - Returns whether or not a point is inside a cube.

    point: (Vector)
        - The position of the point.
    cubePos: (Vector)
        - The position of the cube's center.
    sideLength: (number)
        - The length of each side of the cube.
--]]
function vectorMath.isPointWithinCube( point, cubePos, sideLength )
    local minBounds, maxBounds = vectorMath.getCubeBounds( sideLength )

    minBounds = minBounds + cubePos
    maxBounds = maxBounds + cubePos

    return point:withinAABox( minBounds, maxBounds )
end


----- PRIVATE FUNCTIONS -----

getArgsAsTable = function( ... )
    local args = { ... }

    if #args == 1 then
        local arg1 = args[1]

        if type( arg1 ) == "table" then
            return arg1
        end
    end

    return args
end

isXCloseToY = function( x, y, precision )
    if not precision then return x == y end

    return mAbs( x - y ) <= precision
end

getCylinderBottomAndDirEff = function( length, dir, originIsBottom )
    local dirEff = dir

    if not dir then
        dirEff = Vector( 0, 0, 1 )
    elseif type( dir ) == "Angle" then
        dirEff = dir:getForward()
    end

    if originIsBottom then return Vector( 0, 0, 0 ), dirEff end

    return dirEff * length * ( -0.5 ), dirEff
end

getConeEndRadius = function( length, endRadius, theta )
    if endRadius then return endRadius end

    if not theta then error( "Expected at least one of (endRadius, theta) to be provided." ) end
    if theta < 0 or theta >= PI_HALF then error( "Expected theta to be in the range [0, PI / 2)." ) end

    return length * mTan( theta )
end

getPlaneNormal = function( planeNormalAng )
    local planeNormal

    if planeNormalAng.getForward then
        planeNormal = planeNormalAng:getForward()
    else
        planeNormal = planeNormalAng
        planeNormalAng = planeNormal:getAngle()
    end

    return planeNormal, planeNormalAng
end
