--@name Placeable
--@author legokidlogan
--@shared
--@include lkl/destroyable.txt
--@include lkl/perf_check.txt

--[[
    - TODO
--]]

if Placeable then return end

require( "lkl/destroyable.txt" )
require( "lkl/perf_check.txt" )


Placeable = class( "Placeable", Destroyable )

-- These static vars can be overridden by subclasses, but not by instances.
Placeable.static.SERVER_REPLICATE_ON_CLIENT = false -- Whether or not serverside Placeables should be replicated on client.
Placeable.static.THINK_PERF_LIMIT = 0.9 -- :think() calls will be skipped when the chip's fractional quota exceeds this amount.


local allPlaceables = {}
local placeablesByID = {}
local placeableIncrement = 0
local placeableParents = {}
local placeableParentLookup = {}
local checkForPosAngChanges


----- STATIC FUNCTIONS -----

function Placeable.static:getAll()
    return allPlaceables
end

function Placeable.static:getByID( id )
    return placeablesByID[id]
end


function Placeable:initialize( pos, ang )
    table.insert( allPlaceables, self )

    placeableIncrement = placeableIncrement + 1
    placeablesByID[placeableIncrement] = self
    self._id = placeableIncrement

    self._lastThinkTime = timer.curtime()
    self._thinkDelta = 0

    if self:isReplicatedOnClient() then
        net.start( "LKL_Placeable_Create" )
        net.writeUInt( placeableIncrement, 16 )
        net.writeString( self.class.name )
        net.writeVector( pos )
        net.writeAngle( ang )
        net.send()
    end

    self:setPos( pos )
    self:setAngles( ang )
end


----- INSTANCE FUNCTIONS -----

function Placeable:getID()
    return self._id
end

function Placeable:getTimerName( timerName )
    if type( timerName ) ~= "string" then error( "Expected timerName to be a string" ) end

    return timerName .. "_" .. self:getID()
end

function Placeable:isReplicatedOnClient()
    if CLIENT then return false end

    return self.class.SERVER_REPLICATE_ON_CLIENT
end

function Placeable:isSyncedCopy()
    if SERVER then return false end

    return self._id < 0
end

function Placeable:localToWorld( pos )
    if type( pos ) ~= "Vector" then error( "Expected pos to be a Vector" ) end

    local worldPos = localToWorld( pos, Angle(), self:getPos(), self:getAngles() )

    return worldPos
end

function Placeable:localToWorldAngles( ang )
    if type( ang ) ~= "Angle" then error( "Expected ang to be an Angle" ) end

    local _, localAng = localToWorld( Vector(), ang, Vector(), self:getAngles() )

    return localAng
end

function Placeable:localToWorldPosAng( pos, ang )
    if type( pos ) ~= "Vector" then error( "Expected pos to be a Vector" ) end
    if type( ang ) ~= "Angle" then error( "Expected ang to be an Angle" ) end

    return localToWorld( pos, ang, self:getPos(), self:getAngles() )
end

function Placeable:worldToLocal( pos )
    if type( pos ) ~= "Vector" then error( "Expected pos to be a Vector" ) end

    local localPos = worldToLocal( pos, Angle(), self:getPos(), self:getAngles() )

    return localPos
end

function Placeable:worldToLocalAngles( ang )
    if type( ang ) ~= "Angle" then error( "Expected ang to be an Angle" ) end

    local _, localAng = worldToLocal( Vector(), ang, Vector(), self:getAngles() )

    return localAng
end

function Placeable:worldToLocalPosAng( pos, ang )
    if type( pos ) ~= "Vector" then error( "Expected pos to be a Vector" ) end
    if type( ang ) ~= "Angle" then error( "Expected ang to be an Angle" ) end

    return worldToLocal( pos, ang, self:getPos(), self:getAngles() )
end

-- Sets the position of the Placeable.
function Placeable:setPos( pos )
    if type( pos ) ~= "Vector" then error( "Expected pos to be a Vector" ) end

    local prevPos = self:getPos()
    if prevPos == pos then return end

    local parent = self:getParent()

    if isValid( parent ) then
        self._localPos = parent:worldToLocal( pos )
    end

    self._pos = pos
    self:onSetPos( prevPos )
    self:onPosAngChanged( prevPos, self:getAngles() )

    if self:isReplicatedOnClient() then
        net.start( "LKL_Placeable_SetPos" )
        net.writeUInt( self:getID(), 16 )
        net.writeVector( pos )
        net.send()
    end
end

function Placeable:getPos()
    local parent = self:getParent()
    if isValid( parent ) then return parent:localToWorld( self._localPos ) end

    return self._pos
end

function Placeable:getLocalPos()
    if not isValid( self:getParent() ) then return self._pos end

    return self._localPos
end

-- Sets the angles of the Placeable.
function Placeable:setAngles( ang )
    if type( ang ) ~= "Angle" then error( "Expected ang to be an Angle" ) end

    local prevAng = self:getAngles()
    if prevAng == ang then return end

    local parent = self:getParent()

    if isValid( parent ) then
        self._localAng = parent:worldToLocalAngles( ang )
    end

    self._ang = ang
    self:onSetAngles( prevAng )
    self:onPosAngChanged( self:getPos(), prevAng )

    if self:isReplicatedOnClient() then
        net.start( "LKL_Placeable_SetAngles" )
        net.writeUInt( self:getID(), 16 )
        net.writeAngle( ang )
        net.send()
    end
end

function Placeable:getAngles()
    local parent = self:getParent()
    if isValid( parent ) then return parent:localToWorldAngles( self._localAng ) end

    return self._ang
end

function Placeable:getLocalAngles()
    if not isValid( self:getParent() ) then return self._ang end

    return self._localAng
end

--[[
    - Sets/unsets the parent of the Placeable.
    - To track changes in the Placeable's effective location due to the parent moving, see :onPosAngChanged().
--]]
function Placeable:setParent( ent )
    if ent ~= nil and not isValid( ent ) then error( "Expected ent to be valid or nil" ) end

    local prevParent = self:getParent()
    if prevParent == ent then return end

    local worldPos = self:getPos()
    local worldAng = self:getAngles()
    local localPos = ent and ent:worldToLocal( worldPos )
    local localAng = ent and ent:worldToLocalAngles( worldAng )

    self._parent = ent
    self._localPos = localPos
    self._localAng = localAng
    self._parentPrevPos = ent and ent:getPos()
    self._parentPrevAng = ent and ent:getAngles()

    if ent == nil then
        self._pos = worldPos
        self._ang = worldAng

        if isValid( prevParent ) then
            table.removeByValue( prevParent._placeable_Children, self )
            table.removeByValue( placeableParents, prevParent )
            placeableParentLookup[prevParent] = nil
        end
    else
        local children = ent._placeable_Children

        if not children then
            children = {}
            ent._placeable_Children = children
        end

        table.insert( children, self )
        table.insert( placeableParents, ent )
        placeableParentLookup[ent] = true
    end

    self:onSetParent( prevParent )
    self:onPosAngChanged( worldPos, worldAng )

    if self:isReplicatedOnClient() then
        net.start( "LKL_Placeable_SetParent" )
        net.writeUInt( self:getID(), 16 )
        net.writeEntity( ent or game.getWorld() )
        net.writeVector( localPos or Vector() )
        net.writeAngle( localAng or Angle() )
        net.send()
    end
end

function Placeable:getParent()
    return self._parent
end

-- Acts similarly to timer.frametime(), but accounts for any time the Placeable's :think() gets skipped due to cpu usage.
function Placeable:getThinkDelta()
    return self._thinkDelta
end


----- OVERRIDABLE FUNCTIONS -----

-- Called every tick.
function Placeable:think()

end

--[[
    - Callback for when the Placeable is destroyed.
    - Used for cleaning up props, holograms, etc.
    - Can safely be made different between server and client.
--]]
function Placeable:onDestroyed()

end

--[[
    - Callback for when the effective position and/or angles of the Placeable has changed for any reason.
    - Caused by :setPos(), :setAngles(), :setParent(), or the parent Entity moving.
    -- Can safely be made different between server and client.
--]]
function Placeable:onPosAngChanged( _prevPos, _prevAng )

end

--[[
    - Callback for when the position of the Placeable is changed.
    - Used for updating props, holograms, etc.
    - Can safely be made different between server and client.
    - Note that prevPos will always be nil on the first call.
--]]
function Placeable:onSetPos( _prevPos )

end

--[[
    - Callback for when the angles of the Placeable are changed.
    - Used for updating props, holograms, etc.
    - Can safely be made different between server and client.
    - Note that prevAng will always be nil on the first call.
--]]
function Placeable:onSetAngles( _prevAng )

end

--[[
    - Callback for when the parent of the Placeable is changed.
    - Used for updating props, holograms, etc.
    - Can safely be made different between server and client.
--]]
function Placeable:onSetParent( _prevParent )

end


if SERVER then
    -- Called when a synced serverside Placeable fails to replicate to a client.
    function Placeable:onReplicationFailed( _ply, _err )

    end
end


----- IMPLEMENTED FUNCTIONS -----

function Placeable:tostringInner()
    return "ID " .. self:getID()
end

function Placeable:destroy()
    if self:isSyncedCopy() then error( "Synced Placeables cannot be destroyed manually in the client realm" ) end

    table.removeByValue( allPlaceables, self )
    placeablesByID[self:getID()] = nil

    local children = self._placeable_Children

    if children then
        for _, placeable in ipairs( children ) do
            if isValid( placeable ) and not placeable:isSyncedCopy() then
                placeable:destroy()
            end
        end
    end

    if self:isReplicatedOnClient() then
        net.start( "LKL_Placeable_Destroy" )
        net.writeUInt( self:getID(), 16 )
        net.send()
    end

    Placeable.super.destroy( self )
end


----- PRIVATE FUNCTIONS -----

checkForPosAngChanges = function( placeable )
    local parent = placeable:getParent()
    if not isValid( parent ) then return end

    local parentPrevPos = placeable._parentPrevPos
    local parentPrevAng = placeable._parentPrevAng
    local parentPos = parent:getPos()
    local parentAng = parent:getAngles()
    if parentPrevPos == parentPos and parentPrevAng == parentAng then return end

    local prevPos, prevAng = localToWorld( placeable:getLocalPos(), placeable:getLocalAngles(), parentPrevPos, parentPrevAng )

    placeable._parentPrevPos = parentPos
    placeable._parentPrevAng = parentAng
    placeable:onPosAngChanged( prevPos, prevAng )
end


----- SETUP -----

hook.add( "think", "LKL_Placeable_Think", function()
    local now = timer.curtime()

    for _, placeable in ipairs( allPlaceables ) do
        if not perfCheck( placeable.class.THINK_PERF_LIMIT ) then break end

        local dt = now - placeable._lastThinkTime
        placeable._lastThinkTime = now
        placeable._thinkDelta = dt

        checkForPosAngChanges( placeable )
        placeable:think()
    end
end )

hook.add( "EntityRemoved", "LKL_Placeable_DestroyChildren", function( ent )
    if not placeableParentLookup[ent] then return end

    table.removeByValue( placeableParents, ent )
    placeableParentLookup[ent] = nil

    local children = ent._placeable_Children

    for _, placeable in ipairs( children ) do
        if isValid( placeable ) and not placeable:isSyncedCopy() then
            placeable:destroy()
        end
    end
end )


if SERVER then
    net.receive( "LKL_Placeable_FailedToReplicate", function( _, ply )
        local id = net.readUInt( 16 )
        local err = net.readString()

        local placeable = Placeable:getByID( id )
        if not placeable then return end

        placeable:onReplicationFailed( ply, err )

        print( "Failed to replicate Placeable " .. id .. " to " .. tostring( ply ) .. ": " .. err )
    end )

    return
end


net.receive( "LKL_Placeable_Create", function()
    local id = net.readUInt( 16 )
    local classObj = _G[net.readString()]
    local pos = net.readVector()
    local ang = net.readAngle()

    local placeable
    local success, err = pcall( function()
        placeable = classObj:new( pos, ang )
    end )

    if not success then
        err = type( err ) == "table" and tostring( err.message ) or tostring( err )

        net.start( "LKL_Placeable_FailedToReplicate" )
        net.writeUInt( id, 16 )
        net.writeString( err )
        net.send()

        return
    end

    placeablesByID[placeable._id] = nil
    placeableIncrement = placeableIncrement - 1
    id = -id
    placeablesByID[id] = placeable
    placeable._id = id
end )

net.receive( "LKL_Placeable_Destroy", function()
    local id = -net.readUInt( 16 )
    local placeable = Placeable:getByID( id )
    if not placeable then print( "Tried to :destroy() an invalid Placeable id " .. id ) return end

    function placeable:isSyncedCopy()
        return false
    end

    Placeable.super.destroy( placeable )
end )

net.receive( "LKL_Placeable_SetPos", function()
    local id = -net.readUInt( 16 )
    local placeable = Placeable:getByID( id )
    if not placeable then print( "Tried to :setPos() on an invalid Placeable id " .. id ) return end

    placeable:setPos( net.readVector() )
end )

net.receive( "LKL_Placeable_SetAngles", function()
    local id = -net.readUInt( 16 )
    local placeable = Placeable:getByID( id )
    if not placeable then print( "Tried to :setAngles() on an invalid Placeable id " .. id ) return end

    placeable:setAngles( net.readAngle() )
end )

net.receive( "LKL_Placeable_SetParent", function()
    local id = -net.readUInt( 16 )
    local placeable = Placeable:getByID( id )
    if not placeable then print( "Tried to :setParent() on an invalid Placeable id " .. id ) return end

    local parent = net.readEntity()
    parent = isValid( parent ) and parent or nil

    if not parent then
        placeable:setParent( nil )

        return
    end

    local localPos = net.readVector()
    local localAng = net.readAngle()

    placeable._parent = nil
    placeable._pos = localPos
    placeable._ang = localAng

    placeable:setParent( parent )
end )
