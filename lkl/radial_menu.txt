--@name Radial Menu
--@author legokidlogan
--@client
--@include lkl/destroyable.txt
--@include lkl/cl_check_permissions.txt
--@include lkl/math/nearest_multiple.txt
--@include lkl/math/hsv_math.txt

--[[
    - A heavily customizable, highly performant radial menu class.
    - Each menu can have multiple pages, cycled through with left/right click while hovering over the center.

    - HOOKS:
        LKL_RadialMenu_OnClosed( menu, fromOtherOpening, dontHideCursor )
            - Called when a menu is closed.

            menu: (RadialMenu)
                - The RadialMenu that was closed.
            fromOtherOpening: (boolean)
                - Whether the menu was closed because another menu was opened.
            dontHideCursor: (boolean)
                - True if the menu was told to not hide the cursor.


        LKL_RadialMenu_OnOpened( prevMenu, curMenu, pageInd )
            - Called when a menu is opened.

            prevMenu: (RadialMenu or nil)
                - The menu that was closed in order to open the new one.
                - nil if no menu was open when the new one was opened.

            curMenu: (RadialMenu)
                - The menu that was opened.

            pageInd: (number or nil)
                - The page number the menu was opened to, if specified.
                - If nil, check the menu's current page.


        LKL_RadialMenu_OnDestroyed( menu )
            - Called when a menu is about to be destroyed.

            menu: (RadialMenu)
                - The menu that is being destroyed.


        LKL_RadialMenu_ChoiceClicked( menu, pageInd, choiceInd )
            - Called when a menu's choice is left-clicked.
            - Called immediately before processing the choice's action.
            - Useful for adding universal behaviour like clicking sounds.

            menu: (RadialMenu)
                - The menu that was clicked.

            pageInd: (number)
                - The page number of the choice that was clicked.

            choiceInd: (number)
                - The index of the choice that was clicked.


        LKL_RadialMenu_OnOpenedSubmenu( prevMenu, curMenu, pageInd )
            - Called when a menu is opened directly from the 'menu' parameter of a choice.
            - Called immediately before the menu is opened.

            prevMenu: (RadialMenu)
                - The menu whose choice was clicked to open the new one.

            curMenu: (RadialMenu)
                - The menu that was opened.

            pageInd: (number or nil)
                - The page number the menu was opened to, if specified.
                - If nil, check the menu's current page.


        LKL_RadialMenu_InputPressed( menu, key )
            - Called when a key is pressed with a menu open.
            - Never called for the left mouse button.
            - Never called for the right mouse button when not hovering a choice.

            menu: (RadialMenu)
                - The menu that is open.

            key: (number)
                - The key that was pressed.
                - A member of the KEY or MOUSE enums.
--]]


if RadialMenu then return end

require( "lkl/destroyable.txt" )
require( "lkl/cl_check_permissions.txt" )
require( "lkl/math/nearest_multiple.txt" )
require( "lkl/math/hsv_math.txt" )

permissions = permissions or {}
addPermissions( {
    "input",
} )
setupPermissionRequestSafe( permissions, "Use a radial menu", true )
checkPermissions()


RadialMenu = class( "RadialMenu", Destroyable )

-- These can be changed on a per-instance basis.
RadialMenu.static.HOVER_DURATION = 0.25 -- How long it takes for the (un)hover animation to complete, in seconds.
RadialMenu.static.NAME_ALIGN = TEXT_ALIGN.TOP -- Whether to put the menu's name above, below, or in the center.
RadialMenu.static.NAME_OFFSET = 0.075 -- The distance from the center of the menu to the name, as a fraction of the menu radius. Does nothing for centered alignment.

-- These can be changed per-instance, only by setting the class values before creating a new instance.
RadialMenu.static.FONT = "Roboto Mono"
RadialMenu.static.FONT_SIZE = 20 -- Font size. Gets scaled by scrH / 1080.
RadialMenu.static.FONT_ANTIALIAS = true
RadialMenu.static.FONT_OUTLINE = false
RadialMenu.static.FONT_OUTLINE_THINNESS = 2 -- Larger values result in thinner outlines.
RadialMenu.static.FONT_WEIGHT = 400

RadialMenu.static.RADIUS = 0.25 -- Radius of the menu as a fraction of the screen height. This is the largest radius, i.e. the radius when hovering a choice.
RadialMenu.static.DEADZONE_RADIUS = 0.35 -- Radius of the deadzone as a fraction of the menu radius.
RadialMenu.static.HOVER_EXPAND = 0.05 -- Expands the outside of the hovered choice by a fraction of the menu radius.
RadialMenu.static.HOVER_CONTRACT = 0.2 -- Contracts the inside of the hovered choice by a fraction of the menu radius.
RadialMenu.static.CHOICE_GAP = 0.03 -- Gap between choices as a fraction of the menu radius.

-- These can be changed before creating a new instance, and can be overridden per each choice of each menu page.
RadialMenu.static.CHOICE_GRADIENT_ENABLED = true -- Whether to use an alpha gradient for the choice background, instead of a solid color.
RadialMenu.static.CHOICE_BAND_ENABLED = true -- Whether to draw solid background bands behind choice names.
RadialMenu.static.CHOICE_GRADIENT_COLOR_UNHOVERED = Color( 180, 0.08, 0.19, 255 ) -- The color of the gradient when the choice is unhovered. Choice colors are in HSV.
RadialMenu.static.CHOICE_GRADIENT_COLOR_HOVERED = Color( 180, 1, 1, 255 ) -- The color of the gradient when the choice is hovered.
RadialMenu.static.CHOICE_BAND_COLOR_UNHOVERED = Color( 180, 0.08, 0.19, 255 ) -- The color of the band when the choice is unhovered.
RadialMenu.static.CHOICE_BAND_COLOR_HOVERED = Color( 180, 1, 1, 255 ) -- The color of the band when the choice is hovered.
RadialMenu.static.CHOICE_NAME_COLOR_UNHOVERED = Color( 0, 0, 1, 255 ) -- The color of the choice name when the choice is unhovered.
RadialMenu.static.CHOICE_NAME_COLOR_HOVERED = Color( 0, 0, 1, 255 ) -- The color of the choice name when the choice is hovered.


local MAIN_FONT_SIZE = 32
local MAIN_FONT_OUTLINE = true
local MAIN_FONT_OUTLINE_THINNESS = 1
local PAGE_FONT_SIZE = 24

local CHOICE_FRAME_COUNT = 100
local PERF_LIMIT = 0.75

local VECTOR_MENU_NAME_SCALE = Vector( 1 / MAIN_FONT_OUTLINE_THINNESS )
local VECTOR_PAGE_NAME_SCALE = Vector( ( PAGE_FONT_SIZE / MAIN_FONT_SIZE ) / MAIN_FONT_OUTLINE_THINNESS )

local TEXT_ALIGN_CENTER = TEXT_ALIGN.CENTER
local TEXT_ALIGN_TOP = TEXT_ALIGN.TOP
local TEXT_ALIGN_BOTTOM = TEXT_ALIGN.BOTTOM
local MATH_PI = math.pi

local scrW, scrH = render.getGameResolution()
local mainFontSizeEff = MAIN_FONT_SIZE * scrH / 1080
local pageFontSizeEff = PAGE_FONT_SIZE * scrH / 1080
local pageNumOffsetY = ( mainFontSizeEff + pageFontSizeEff ) * 0.5
local pageNameOffsetY = pageNumOffsetY + pageFontSizeEff
local mainFont = render.createFont( "Roboto Mono", mainFontSizeEff * MAIN_FONT_OUTLINE_THINNESS, 400, true, false, false, MAIN_FONT_OUTLINE )
local matGradient = material.load( "gui/gradient_up" )
local menusByName = {}
local curMenu = nil
local prevMenu = nil
local hoveredInd = nil

local menuFontLookup = {}
local choicePolySetsLookup = {}
local choiceGradientColorsLookup = {}
local choiceBandColorsLookup = {}
local choiceNameColorsLookup = {}

local matrCenter = Matrix()
matrCenter:translate( Vector( scrW / 2, scrH / 2, 0 ) )

local calcFontAndRadius
local addPolyUser
local removePolyUser
local addColorUser
local removeColorUser
local makePolyFrame
local getColorFrame
local moveColorUser
local nudgePolyUsers
local nudgeColorUsers
local editChoice
local validatePolyUser
local handleChoiceClick
local resetHoverProgress
local getColorEff


----- STATIC FUNCTIONS -----

--[[
    name: string
        - The name of the menu.
        - Must be unique.
    displayName: string
        - The display name of the menu.
    pages: table
        - A sequential list of page details.
        - At least one page is required.
        - Each page should contain three or more choices.
        {
            [1] = { -- (page 1)
                name = STRING (optional), -- The name of the page.

                [1] = { -- (choice 1 of page 1)
                    name = STRING, -- The name of the choice. Supports newlines. Text automatically shrinks to fit.

                    -- These are mutually exclusive with each other. At least one must be set.
                    command = STRING, -- The concmd to run when the choice is selected. Only works on the owner, otherwise tries the other options.
                    menu = STRING, -- The name of the menu to open when the choice is selected.
                        menuPageInd = NUMBER (optional), -- The page to open when the choice is selected, if menu is used. nil to not force the page.
                    func = function( menu, pageInd, choiceInd ) end, -- A function to run when the choice is selected.

                    -- See the CHOICE_ static vars of RadialMenu for more info and defaults. Colors are in HSV.
                    gradientEnabled = BOOLEAN (optional),
                    bandEnabled = BOOLEAN (optional),
                    gradientColorUnhovered = COLOR_HSV (optional),
                    gradientColorHovered = COLOR_HSV (optional),
                    bandColorUnhovered = COLOR_HSV (optional),
                    bandColorHovered = COLOR_HSV (optional),
                    nameColorUnhovered = COLOR_HSV (optional),
                    nameColorHovered = COLOR_HSV (optional),

                    -- This function allows for extra rendering.
                    -- Drawing at 0,0 will result in drawing at the center of the menu/screen.
                    -- Drawing at xDir * choiceRadius, yDir * choiceRadius will result in drawing at the outermost edge of the choice.
                    -- The render will be facing upright.
                    paint = function( xDir, yDir, choiceRadius, bandHeight, hovered, menu, pageInd, choiceInd, hoverProgress ) return end (optional),

                    -- This function is like paint, but inherits the choice's radial orientation.
                    -- Drawing at 0, -choiceRadius will result in drawing at the outermost edge of the choice.
                    -- Note that choices below the center have their rotation flipped for ease of readability.
                    paintRadial = function( choiceRadius, bandHeight, hovered, menu, pageInd, choiceInd, hoverProgress ) return end (optional),
                },
                ...
            },
            ...
        }
--]]
function RadialMenu:initialize( name, displayName, pages )
    if type( name ) ~= "string" then error( "Expected name to be a string" ) end
    if type( displayName ) ~= "string" then error( "Expected displayName to be a string" ) end
    if type( pages ) ~= "table" then error( "Expected displayName to be a table" ) end

    if isValid( menusByName[name] ) then
        error( "A radial menu with that name already exists" )
    end

    self._name = name
    self._displayName = displayName
    self._pages = {}
    self._curPageInd = 1

    calcFontAndRadius( self )
    self._choiceGradientEnabled = self.class.CHOICE_GRADIENT_ENABLED
    self._choiceBandEnabled = self.class.CHOICE_BAND_ENABLED
    self._choiceGradientColorUnhovered = self.class.CHOICE_GRADIENT_COLOR_UNHOVERED:clone()
    self._choiceGradientColorHovered = self.class.CHOICE_GRADIENT_COLOR_HOVERED:clone()
    self._choiceBandColorUnhovered = self.class.CHOICE_BAND_COLOR_UNHOVERED:clone()
    self._choiceBandColorHovered = self.class.CHOICE_BAND_COLOR_HOVERED:clone()
    self._choiceNameColorUnhovered = self.class.CHOICE_NAME_COLOR_UNHOVERED:clone()
    self._choiceNameColorHovered = self.class.CHOICE_NAME_COLOR_HOVERED:clone()

    self:setPages( pages )

    menusByName[name] = self
end

function RadialMenu.static:getMenuByName( name )
    return menusByName[name]
end

function RadialMenu.static:getCurMenu()
    return curMenu
end

function RadialMenu.static:getPrevMenu()
    return prevMenu
end

function RadialMenu.static:getHoveredInd()
    return hoveredInd
end

function RadialMenu.static:closeCurMenu( dontHideCursor )
    if curMenu then
        curMenu:close( dontHideCursor )
    end
end

-- Simulates a left click on the currently hovered choice.
function RadialMenu.static:forceClickHovered()
    if not curMenu or not hoveredInd then return end

    handleChoiceClick()
end


----- INSTANCE FUNCTIONS -----

function RadialMenu:isOpen()
    return curMenu == self
end

function RadialMenu:setCurPageInd( pageInd )
    local oldPageInd = self._curPageInd
    if oldPageInd == pageInd then return end

    if pageInd < 1 or pageInd > #self._pages then
        error( "Expected pageInd to be between 1 and pageCount" )
    end

    self._curPageInd = pageInd
    resetHoverProgress( self )

    if curMenu == self then
        hoveredInd = nil
    end

    self:onPageChanged( oldPageInd, pageInd )
end

function RadialMenu:getCurPageInd()
    return self._curPageInd
end

function RadialMenu:getCurPageChoiceCount()
    local page = self._pages[self._curPageInd]
    if not page then return end

    return #page
end

function RadialMenu:getPageChoiceCount( pageInd )
    local page = self._pages[pageInd]
    if not page then error( "Expected pageInd to be between 1 and pageCount" ) end

    return #page
end

function RadialMenu:getPageCount()
    return #self._pages
end

function RadialMenu:getHoveredInd()
    return curMenu == self and hoveredInd
end

--[[
    - Opens the menu (to a page), or changes the page if already open.

    pageInd: number (optional)
        - The page to open to.
        - If not set, the current page will be opened.

    RETURNS: failedToOpen
        failedToOpen: boolean or nil
            - If true, the menu was unable to be opened.
                - This occurs when permissions are not satisfied, or no HUD is connected.
            - If false, the menu has been opened.
            - If nil, the menu was already open.
--]]
function RadialMenu:open( pageInd )
    if curMenu == self then
        if pageInd then
            self:setCurPageInd( pageInd )
        end

        return
    end

    if not permissionSatisfied or not render.isHUDActive() then return true end

    prevMenu = isValid( curMenu ) and curMenu or nil
    curMenu = self
    hoveredInd = nil

    if prevMenu then
        prevMenu:onClosed( true, true )
        hook.run( "LKL_RadialMenu_OnClosed", prevMenu, true, true )
    else
        input.enableCursor( true )
    end

    if pageInd then
        self:setCurPageInd( pageInd )
    else
        resetHoverProgress( self )
    end

    self:onOpened( prevMenu, pageInd )
    hook.run( "LKL_RadialMenu_OnOpened", prevMenu, self, pageInd )

    return false
end

--[[
    - Closes the menu.

    dontHideCursor: boolean (optional)
        - If true, the cursor will not be hidden.
        - False by default.
--]]
function RadialMenu:close( dontHideCursor )
    if curMenu ~= self then return end

    prevMenu = self
    curMenu = nil
    hoveredInd = nil

    if not dontHideCursor and permissionSatisfied and render.isHUDActive() then
        input.enableCursor( false )
    end

    self:onClosed( false, dontHideCursor )
    hook.run( "LKL_RadialMenu_OnClosed", self, false, dontHideCursor )
end

function RadialMenu:setHoverDuration( duration )
    if duration ~= nil then
        if type( duration ) ~= "number" then error( "Expected duration to be a number or nil" ) end
        if duration > 0 then error( "Expected duration to be greater than 0" ) end
    end

    self._hoverDuration = duration
end

function RadialMenu:getHoverDuration()
    return self._hoverDuration or self.class.HOVER_DURATION
end

function RadialMenu:setNameAlign( align )
    if align ~= nil then
        if type( align ) ~= "number" then error( "Expected align to be a number or nil" ) end
        if align ~= TEXT_ALIGN.TOP and align ~= TEXT_ALIGN.CENTER and align ~= TEXT_ALIGN.BOTTOM then
            error( "Expected align to be one of the three vertical text alignments" )
        end
    end

    self._nameAlign = align
end

function RadialMenu:getNameAlign()
    return self._nameAlign or self.class.NAME_ALIGN
end

function RadialMenu:setNameOffset( offset )
    if offset ~= nil and type( offset ) ~= "number" then error( "Expected offset to be a number or nil" ) end

    self._nameOffset = offset
end

function RadialMenu:getNameOffset()
    return self._nameOffset or self.class.NAME_OFFSET
end

-- Overrides the pages. See RadialMenu:initialize() for page format.
function RadialMenu:setPages( pages )
    if type( pages ) ~= "table" then error( "Expected pages to be a table" ) end
    if #pages < 1 then error( "Expected pages to have at least one page" ) end

    for i, page in ipairs( pages ) do
        if type( page ) ~= "table" then error( "Expected page " .. i .. " to be a table" ) end
        if #page < 3 then error( "Expected page " .. i .. " to have at least three choices" ) end
    end

    local menuNamePrepend = self:getName() .. "_"
    local realPages = self._pages
    local curPageInd = self:getCurPageInd()

    for i = 1, #realPages do
        local page = realPages[i]
        local pageUID = menuNamePrepend .. i
        local pageUIDPrepend = pageUID .. "_"
        local polyStr = page.polyStr

        if polyStr then
            removePolyUser( pageUID, polyStr )
        end

        for i2 = 1, #page do
            local choice = page[i2]
            local choiceUID = pageUIDPrepend .. i2

            removeColorUser( choiceGradientColorsLookup, choiceUID, choice.gradientColorStr )
            removeColorUser( choiceBandColorsLookup, choiceUID, choice.bandColorStr )
            removeColorUser( choiceNameColorsLookup, choiceUID, choice.nameColorStr )

            page[i2] = nil
        end

        realPages[i] = nil
    end

    local choiceGradientEnabled = self:isChoiceGradientEnabled()
    local choiceBandEnabled = self:isChoiceBandEnabled()
    local choiceGradientColorUnhovered = self._choiceGradientColorUnhovered
    local choiceGradientColorHovered = self._choiceGradientColorHovered
    local choiceBandColorUnhovered = self._choiceBandColorUnhovered
    local choiceBandColorHovered = self._choiceBandColorHovered
    local choiceNameColorUnhovered = self._choiceNameColorUnhovered
    local choiceNameColorHovered = self._choiceNameColorHovered

    for i = 1, #pages do
        local pageUID = menuNamePrepend .. i
        local pageUIDPrepend = pageUID .. "_"
        local page = pages[i]
        local realPage = {
            name = page.name,
        }
        realPages[i] = realPage

        for i2 = 1, #page do
            realPage[i2] = {}
            editChoice( realPage, pageUIDPrepend, i2, page[i2],
                choiceGradientEnabled,
                choiceBandEnabled,
                choiceGradientColorUnhovered,
                choiceGradientColorHovered,
                choiceBandColorUnhovered,
                choiceBandColorHovered,
                choiceNameColorUnhovered,
                choiceNameColorHovered
            )
        end
    end

    if curMenu == self then
        hoveredInd = nil
    end

    self:setCurPageInd( math.clamp( curPageInd, 1, #realPages ) )
end

-- Inserts a new page. See RadialMenu:initialize() for page format.
function RadialMenu:insertPage( pageInd, page )
    if type( pageInd ) ~= "number" then error( "Expected pageInd to be a number" ) end
    if math.floor( pageInd ) ~= pageInd then error( "Expected pageInd to be an integer" ) end
    if type( page ) ~= "table" then error( "Expected page to be a table" ) end
    if #page < 3 then error( "Expected page to have at least three choices" ) end

    local realPages = self._pages
    if pageInd < 1 or pageInd > #realPages + 1 then
        error( "Expected pageInd to be between 1 and pageCount + 1" )
    end

    for i = 1, #page do
        if type( page[i] ) ~= "table" then error( "Expected choice " .. i .. " of page to be a table" ) end
        if type( page[i].name ) ~= "string" then error( "Expected choice name to be a string" ) end
    end

    nudgePolyUsers( self, pageInd, #realPages, 1 )

    local pageUID = self:getName() .. "_" .. pageInd
    local pageUIDPrepend = pageUID .. "_"

    local choiceGradientEnabled = self:isChoiceGradientEnabled()
    local choiceBandEnabled = self:isChoiceBandEnabled()
    local choiceGradientColorUnhovered = self._choiceGradientColorUnhovered
    local choiceGradientColorHovered = self._choiceGradientColorHovered
    local choiceBandColorUnhovered = self._choiceBandColorUnhovered
    local choiceBandColorHovered = self._choiceBandColorHovered
    local choiceNameColorUnhovered = self._choiceNameColorUnhovered
    local choiceNameColorHovered = self._choiceNameColorHovered

    local realPage = {
        name = page.name,
    }

    table.insert( realPages, pageInd, realPage )

    for i = 1, #page do
        realPage[i] = {}
        editChoice( realPage, pageUIDPrepend, i, page[i],
            choiceGradientEnabled,
            choiceBandEnabled,
            choiceGradientColorUnhovered,
            choiceGradientColorHovered,
            choiceBandColorUnhovered,
            choiceBandColorHovered,
            choiceNameColorUnhovered,
            choiceNameColorHovered
        )
    end

    local curPageInd = self:getCurPageInd()

    if curPageInd >= pageInd then
        self:setCurPageInd( curPageInd + 1 )
    end
end

-- Removes a page. There must always be at least one page, so it's best to insert before removing.
function RadialMenu:removePage( pageInd )
    if type( pageInd ) ~= "number" then error( "Expected pageInd to be a number" ) end
    if math.floor( pageInd ) ~= pageInd then error( "Expected pageInd to be an integer" ) end

    local realPages = self._pages
    if #realPages == 1 then error( "Cannot remove all pages" ) end
    if pageInd < 1 or pageInd > #realPages then
        error( "Expected pageInd to be between 1 and pageCount" )
    end

    local page = realPages[pageInd]
    local pageUID = self:getName() .. "_" .. pageInd
    local pageUIDPrepend = pageUID .. "_"
    local polyStr = page.polyStr

    if polyStr then
        removePolyUser( pageUID, page.polyStr )
    end

    for i = 1, #page do
        local choice = page[i]
        local choiceUID = pageUIDPrepend .. i

        removeColorUser( choiceGradientColorsLookup, choiceUID, choice.gradientColorStr )
        removeColorUser( choiceBandColorsLookup, choiceUID, choice.bandColorStr )
        removeColorUser( choiceNameColorsLookup, choiceUID, choice.nameColorStr )
    end

    nudgePolyUsers( self, pageInd + 1, #realPages, -1 )
    table.remove( realPages, pageInd )

    local curPageInd = self:getCurPageInd()

    if curPageInd >= pageInd then
        if curMenu == self and curPageInd == pageInd then
            hoveredInd = nil
        end

        if curPageInd == 1 then
            self:onPageChanged( 1, 1 )
        else
            self:setCurPageInd( curPageInd - 1 )
        end
    end
end

-- Inserts a new choice into a new page. See RadialMenu:initialize() for choice format.
function RadialMenu:insertChoice( pageInd, choiceInd, choice )
    if type( pageInd ) ~= "number" then error( "Expected pageInd to be a number" ) end
    if math.floor( pageInd ) ~= pageInd then error( "Expected pageInd to be an integer" ) end
    if type( choiceInd ) ~= "number" then error( "Expected choiceInd to be a number" ) end
    if math.floor( choiceInd ) ~= choiceInd then error( "Expected choiceInd to be an integer" ) end
    if type( choice ) ~= "table" then error( "Expected choice to be a table" ) end
    if type( choice.name ) ~= "string" then error( "Expected choice name to be a string" ) end

    local realPages = self._pages
    if pageInd < 1 or pageInd > #realPages then
        error( "Expected pageInd to be between 1 and pageCount" )
    end

    local page = realPages[pageInd]
    local choiceCount = #page
    if choiceInd < 1 or choiceInd > choiceCount + 1 then
        error( "Expected choiceInd to be between 1 and choiceCount + 1" )
    end

    local pageUID = self:getName() .. "_" .. pageInd
    local pageUIDPrepend = pageUID .. "_"

    nudgeColorUsers( page, pageUID, choiceInd, choiceCount, 1 )
    table.insert( page, choiceInd, {} )
    editChoice( page, pageUIDPrepend, choiceInd, choice, self )

    if curMenu == self and self:getCurPageInd() == pageInd then
        hoveredInd = nil
    end
end

-- Removes a choice from a page. There must always be at least three choices, so it's best to insert before removing.
function RadialMenu:removeChoice( pageInd, choiceInd )
    if type( pageInd ) ~= "number" then error( "Expected pageInd to be a number" ) end
    if math.floor( pageInd ) ~= pageInd then error( "Expected pageInd to be an integer" ) end
    if type( choiceInd ) ~= "number" then error( "Expected choiceInd to be a number" ) end
    if math.floor( choiceInd ) ~= choiceInd then error( "Expected choiceInd to be an integer" ) end

    local realPages = self._pages
    if pageInd < 1 or pageInd > #realPages then
        error( "Expected pageInd to be between 1 and pageCount" )
    end

    local page = realPages[pageInd]
    local choiceCount = #page
    if choiceInd < 1 or choiceInd > choiceCount then
        error( "Expected choiceInd to be between 1 and choiceCount" )
    end

    local pageUID = self:getName() .. "_" .. pageInd
    local pageUIDPrepend = pageUID .. "_"
    local choice = page[choiceInd]
    local choiceUID = pageUIDPrepend .. choiceInd

    removeColorUser( choiceGradientColorsLookup, choiceUID, choice.gradientColorStr )
    removeColorUser( choiceBandColorsLookup, choiceUID, choice.bandColorStr )
    removeColorUser( choiceNameColorsLookup, choiceUID, choice.nameColorStr )
    nudgeColorUsers( page, pageUID, choiceInd + 1, choiceCount, -1 )
    table.remove( page, choiceInd )

    if curMenu == self and self:getCurPageInd() == pageInd then
        hoveredInd = nil
    end
end

-- Edits a choice on a page. See RadialMenu:initialize() for choice format.
function RadialMenu:editChoice( pageInd, choiceInd, choice )
    if type( pageInd ) ~= "number" then error( "Expected pageInd to be a number" ) end
    if math.floor( pageInd ) ~= pageInd then error( "Expected pageInd to be an integer" ) end
    if type( choiceInd ) ~= "number" then error( "Expected choiceInd to be a number" ) end
    if math.floor( choiceInd ) ~= choiceInd then error( "Expected choiceInd to be an integer" ) end
    if type( choice ) ~= "table" then error( "Expected choice to be a table" ) end
    if type( choice.name ) ~= "string" then error( "Expected choice name to be a string" ) end

    local realPages = self._pages
    if pageInd < 1 or pageInd > #realPages then
        error( "Expected pageInd to be between 1 and pageCount" )
    end

    local page = realPages[pageInd]
    local choiceCount = #page
    if choiceInd < 1 or choiceInd > choiceCount then
        error( "Expected choiceInd to be between 1 and choiceCount" )
    end

    local pageUIDPrepend = self:getName() .. "_" .. pageInd .. "_"

    editChoice( page, pageUIDPrepend, choiceInd, choice, self )
end

function RadialMenu:getName()
    return self._name
end

function RadialMenu:getDisplayName()
    return self._displayName
end

function RadialMenu:isChoiceGradientEnabled()
    return self._choiceGradientEnabled
end

function RadialMenu:isChoiceBandEnabled()
    return self._choiceBandEnabled
end

function RadialMenu:getChoiceGradientColorUnhovered()
    return self._choiceGradientColorUnhovered:clone()
end

function RadialMenu:getChoiceGradientColorHovered()
    return self._choiceGradientColorHovered:clone()
end

function RadialMenu:getChoiceBandColorUnhovered()
    return self._choiceBandColorUnhovered:clone()
end

function RadialMenu:getChoiceBandColorHovered()
    return self._choiceBandColorHovered:clone()
end

function RadialMenu:getChoiceNameColorUnhovered()
    return self._choiceNameColorUnhovered:clone()
end

function RadialMenu:getChoiceNameColorHovered()
    return self._choiceNameColorHovered:clone()
end

function RadialMenu:getRadius()
    return self._radius
end

-- The actual pixel value of the maximum radius.
function RadialMenu:getRadiusEff()
    return self._radiusHovered
end

function RadialMenu:getDeadzoneRadius()
    return self._deadzoneRadius
end

-- The actual pixel value of the deadzone radius.
function RadialMenu:getDeadzoneRadiusEff()
    return self._radiusInnerUnhovered
end

function RadialMenu:getHoverExpand()
    return self._hoverExpand
end

function RadialMenu:getHoverContract()
    return self._hoverContract
end

function RadialMenu:getChoiceGap()
    return self._choiceGap
end

-- Gets the current effective gradient color of a choice. Returns by reference, do not modify.
-- Provide hoverProgress to force-calculate at a fraction of your choice, independent of the choice's current state.
function RadialMenu:getChoiceGradientColorEff( pageInd, choiceInd, hoverProgress )
    return getColorEff( self, pageInd, choiceInd, hoverProgress, choiceGradientColorsLookup, "_gradientColorEff", "gradientColorStr" )
end

-- Gets the current effective band color of a choice. Returns by reference, do not modify.
-- Provide hoverProgress to force-calculate at a fraction of your choice, independent of the choice's current state.
function RadialMenu:getChoiceBandColorEff( pageInd, choiceInd, hoverProgress )
    return getColorEff( self, pageInd, choiceInd, hoverProgress, choiceBandColorsLookup, "_bandColorEff", "bandColorStr" )
end

-- Gets the current effective name color of a choice. Returns by reference, do not modify.
-- Provide hoverProgress to force-calculate at a fraction of your choice, independent of the choice's current state.
function RadialMenu:getChoiceNameColorEff( pageInd, choiceInd, hoverProgress )
    return getColorEff( self, pageInd, choiceInd, hoverProgress, choiceNameColorsLookup, "_nameColorEff", "nameColorStr" )
end

-- Gets the current hover progress of a choice. This is a value between 0 and 1.
function RadialMenu:getChoiceHoverProgress( pageInd, choiceInd )
    return self._pages[pageInd][choiceInd]._hoverProgress
end


----- OVERRIDABLE FUNCTIONS -----

--[[
    - Called when the menu is opened.
    - DO NOT call :open() inside this function, it could cause an infinite loop.

    prevMenu: RadialMenu or nil
        - The menu that was just closed to open this one.
            - If a menu is :close()'d manually and another is :open()'d after, this will be nil.
        - This is the same as the argument passed to :close().
    pageInd: number or nil
        - The index of the page that was just opened to, or nil if it was not specified.
        - This is the same as the argument passed to :open().
--]]
function RadialMenu:onOpened( _prevMenu, _pageInd )
end

--[[
    - Called when the menu is opened.
    - DO NOT call :open() or :close() inside this function, it could cause an infinite loop.

    fromOtherOpening: boolean
        - Whether the menu was closed due to another menu being opened in its place.
    dontHideCursor: boolean
        - Passed from the args of the :close() function.
--]]
function RadialMenu:onClosed( _fromOtherOpening, _dontHideCursor )
end

--[[
    - Called when the page is changed.
    - DO NOT call :setCurPageInd() inside this function, it could cause an infinite loop.

    oldPageInd: number
        - The index of the page that was just closed.
    newPageInd: number
        - The index of the page that was just opened.
--]]
function RadialMenu:onPageChanged( _oldPageInd, _newPageInd )
end



----- IMPLEMENTED FUNCTIONS -----

function RadialMenu:destroy()
    -- Run the hook before any :onDestroyed functions run to ensure no data is missing for the hook listeners.
    hook.run( "LKL_RadialMenu_OnDestroyed", self )

    RadialMenu.super.destroy( self )
end

function RadialMenu:onDestroyed()
    local menuNamePrepend = self:getName() .. "_"
    local realPages = self._pages

    for i = 1, #realPages do
        local page = realPages[i]
        local pageUID = menuNamePrepend .. i
        local pageUIDPrepend = pageUID .. "_"

        removePolyUser( pageUID, page.polyStr )

        for i2 = 1, #page do
            local choice = page[i2]
            local choiceUID = pageUIDPrepend .. i2

            removeColorUser( choiceGradientColorsLookup, choiceUID, choice.gradientColorStr )
            removeColorUser( choiceBandColorsLookup, choiceUID, choice.bandColorStr )
            removeColorUser( choiceNameColorsLookup, choiceUID, choice.nameColorStr )

            page[i2] = nil
        end

        realPages[i] = nil
    end

    if curMenu == self then
        curMenu = nil
        input.enableCursor( false )
    end

    menusByName[self._name] = nil
end


----- PRIVATE FUNCTIONS -----

calcFontAndRadius = function( menu )
    local menuClass = menu.class
    local font = menuClass.FONT
    local fontSize = menuClass.FONT_SIZE
    local fontAntialias = menuClass.FONT_ANTIALIAS
    local fontOutline = menuClass.FONT_OUTLINE
    local fontOutlineThinness = menuClass.FONT_OUTLINE_THINNESS
    local fontWeight = menuClass.FONT_WEIGHT
    local fontSizeEff = fontSize * scrH / 1080

    menu._font = font
    menu._fontSize = fontSize
    menu._fontAntialias = fontAntialias
    menu._fontOutline = fontOutline
    menu._fontOutlineThinness = fontOutlineThinness
    menu._fontWeight = fontWeight
    menu._fontSizeEff = fontSizeEff
    menu._fontVecScale = Vector( 1 / fontOutlineThinness )

    local fontStr = font .. "_" .. fontSize .. "_" .. tostring( fontAntialias ) .. "_" .. tostring( fontOutline ) .. "_" .. fontOutlineThinness .. "_" .. fontWeight
    local fontObj = menuFontLookup[fontStr]

    if not fontObj then
        fontObj = render.createFont( font, fontSizeEff * fontOutlineThinness, fontWeight, fontAntialias, false, false, fontOutline )
        menuFontLookup[fontStr] = fontObj
    end

    menu._fontObj = fontObj

    render.setFont( fontObj )
    local _, fontHeight = render.getTextSize( "ABCDEFGHIJKLMNOPQRSTUVWXYZ" )
    fontHeight = fontHeight / fontOutlineThinness

    local menuRadius = menuClass.RADIUS
    local deadzoneRadius = menuClass.DEADZONE_RADIUS
    local hoverExpand = menuClass.HOVER_EXPAND
    local hoverContract = menuClass.HOVER_CONTRACT
    local choiceGap = menuClass.CHOICE_GAP

    local radiusHovered = scrH * menuRadius
    local radiusUnhovered = radiusHovered * ( 1 - hoverExpand )
    local radiusInnerUnhovered = radiusHovered * deadzoneRadius
    local radiusInnerHovered = radiusInnerUnhovered + ( radiusHovered - radiusInnerUnhovered ) * hoverContract
    local bandHeight = fontHeight * 2.25

    menu._radius = menuRadius
    menu._deadzoneRadius = deadzoneRadius
    menu._hoverExpand = hoverExpand
    menu._hoverContract = hoverContract
    menu._choiceGap = choiceGap

    menu._radiusHovered = radiusHovered
    menu._radiusUnhovered = radiusUnhovered
    menu._radiusInnerUnhovered = radiusInnerUnhovered
    menu._radiusInnerHovered = radiusInnerHovered
    menu._bandHeight = bandHeight
end

addPolyUser = function( uid, radiusHovered, radiusUnhovered, radiusInnerUnhovered, radiusInnerHovered, bandHeight, choiceGap, choiceCount )
    local polyStr = radiusHovered .. "_" .. radiusUnhovered .. "_" .. radiusInnerUnhovered .. "_" .. radiusInnerHovered .. "_" .. bandHeight .. "_" .. choiceGap .. "_" .. choiceCount
    local polySetsByFrame = choicePolySetsLookup[polyStr]

    if not polySetsByFrame then
        local menuCircumference = 2 * MATH_PI * radiusHovered
        local choiceArc = ( menuCircumference / choiceCount ) - radiusHovered * choiceGap
        local choiceRadHalf = choiceArc / ( radiusHovered * 2 )

        local rad90 = MATH_PI / 2
        local dirRightX = math.cos( rad90 - choiceRadHalf )
        local dirRightY = -math.sin( rad90 - choiceRadHalf )
        local dirLeftX = math.cos( rad90 + choiceRadHalf )
        local dirLeftY = -math.sin( rad90 + choiceRadHalf )
        local inscribeMult = math.cos( MATH_PI / choiceCount ) -- Accounts for name radius loss due to inscribing the circle.

        polySetsByFrame = {
            users = {},
            gradientPolys = {},
            bandPolys = {},
            nameRadii = {},
            radiusHovered = radiusHovered,
            radiusUnhovered = radiusUnhovered,
            radiusInnerUnhovered = radiusInnerUnhovered,
            radiusInnerHovered = radiusInnerHovered,
            bandHeight = bandHeight,
            choiceGap = choiceGap,
            choiceCount = choiceCount,
            dirRightX = dirRightX,
            dirRightY = dirRightY,
            dirLeftX = dirLeftX,
            dirLeftY = dirLeftY,
            inscribeMult = inscribeMult,
        }
        choicePolySetsLookup[polyStr] = polySetsByFrame
    end

    polySetsByFrame.users[uid] = true

    return polyStr
end

removePolyUser = function( uid, polyStr )
    local polySetsByFrame = choicePolySetsLookup[polyStr]
    if not polySetsByFrame then return end

    local users = polySetsByFrame.users

    users[uid] = nil

    if next( users ) ~= nil then return end

    polySetsByFrame.users = nil
    polySetsByFrame.gradientPolys = nil
    polySetsByFrame.bandPolys = nil
    polySetsByFrame.nameRadii = nil

    choicePolySetsLookup[polyStr] = nil
end

addColorUser = function( lookup, uid, color1, color2 )
    local h1 = color1.r
    local s1 = color1.g
    local v1 = color1.b
    local a1 = color1.a

    local h2 = color2.r
    local s2 = color2.g
    local v2 = color2.b
    local a2 = color2.a

    local colorStr = h1 .. "_" .. s1 .. "_" .. v1 .. "_" .. a1 .. "_" .. h2 .. "_" .. s2 .. "_" .. v2 .. "_" .. a2
    local colorsByFrame = lookup[colorStr]

    if not colorsByFrame then
        local same = h1 == h2 and s1 == s2 and v1 == v2 and a1 == a2
        color1 = same and hsvMath.hsvToRGB( color1 ) or Color( h1, s1, v1, a1 )
        color2 = same and color1 or Color( h2, s2, v2, a2 )

        colorsByFrame = {
            users = {},
            color1 = color1,
            color2 = color2,
            same = same,
        }
        lookup[colorStr] = colorsByFrame
    end

    colorsByFrame.users[uid] = true

    return colorStr
end

removeColorUser = function( lookup, uid, colorStr )
    local colorsByFrame = lookup[colorStr]
    if not colorsByFrame then return end

    local users = colorsByFrame.users

    users[uid] = nil

    if next( users ) ~= nil then return end

    colorsByFrame.users = nil
    colorsByFrame.color1 = nil
    colorsByFrame.color2 = nil

    lookup[colorStr] = nil
end

makePolyFrame = function( polySetsByFrame, frameInd )
    local radiusHovered = polySetsByFrame.radiusHovered
    local radiusUnhovered = polySetsByFrame.radiusUnhovered
    local radiusInnerUnhovered = polySetsByFrame.radiusInnerUnhovered
    local radiusInnerHovered = polySetsByFrame.radiusInnerHovered
    local bandHeight = polySetsByFrame.bandHeight
    --local choiceGap = polySetsByFrame.choiceGap
    --local choiceCount = polySetsByFrame.choiceCount
    local dirRightX = polySetsByFrame.dirRightX
    local dirRightY = polySetsByFrame.dirRightY
    local dirLeftX = polySetsByFrame.dirLeftX
    local dirLeftY = polySetsByFrame.dirLeftY
    local inscribeMult = polySetsByFrame.inscribeMult

    local frac = frameInd / CHOICE_FRAME_COUNT
    local radiusOuter = math.lerp( frac, radiusUnhovered, radiusHovered )
    local radiusInner = math.lerp( frac, radiusInnerUnhovered, radiusInnerHovered )
    local bandInner = radiusOuter - bandHeight

    polySetsByFrame.gradientPolys[frameInd] = {
        { x = dirRightX * radiusOuter, y = dirRightY * radiusOuter, u = 1, v = 1 },
        { x = dirRightX * radiusInner, y = dirRightY * radiusInner, u = 1, v = 0.01 },
        { x = dirLeftX * radiusInner, y = dirLeftY * radiusInner, u = 0.01, v = 0.01 },
        { x = dirLeftX * radiusOuter, y = dirLeftY * radiusOuter, u = 0.01, v = 1 },
    }

    polySetsByFrame.bandPolys[frameInd] = {
        { x = dirRightX * radiusOuter, y = dirRightY * radiusOuter, u = 1, v = 1 },
        { x = dirRightX * bandInner, y = dirRightY * bandInner, u = 1, v = 0.01 },
        { x = dirLeftX * bandInner, y = dirLeftY * bandInner, u = 0.01, v = 0.01 },
        { x = dirLeftX * radiusOuter, y = dirLeftY * radiusOuter, u = 0.01, v = 1 },
    }

    polySetsByFrame.nameRadii[frameInd] = inscribeMult * ( bandInner + radiusOuter ) / 2 + scrH * 0.002
end

getColorFrame = function( lookup, colorStr, frameInd )
    local colorsByFrame = lookup[colorStr]
    if colorsByFrame.same then return colorsByFrame.color1 end

    local color = colorsByFrame[frameInd]
    if color then return color end

    local frac = frameInd / CHOICE_FRAME_COUNT
    local color1 = colorsByFrame.color1
    local color2 = colorsByFrame.color2

    color = hsvMath.lerpHSVToRGB( frac, color1, color2 )
    colorsByFrame[frameInd] = color

    return color
end

moveColorUser = function( lookup, colorStr, uidOld, uidNew )
    local colorsByFrame = lookup[colorStr]
    if not colorsByFrame then return end

    local users = colorsByFrame.users

    users[uidOld] = nil
    users[uidNew] = true
end

nudgePolyUsers = function( menu, indStart, indEnd, dir )
    local menuNamePrepend = menu:getName() .. "_"
    local pages = menu._pages

    for i = indStart, indEnd do
        local page = pages[i]
        local pageUID = menuNamePrepend .. i
        local pageUIDPrepend = pageUID .. "_"
        local pageUIDNew = menuNamePrepend .. ( i + dir )
        local pageUIDNewPrepend = pageUIDNew .. "_"
        local polyStr = page.polyStr

        if polyStr then
            local polySetsByFrame = choicePolySetsLookup[polyStr]
            local users = polySetsByFrame.users

            users[pageUID] = nil
            users[pageUIDNew] = true
        end

        for i2 = 1, #page do
            local choice = page[i2]
            local choiceUID = pageUIDPrepend .. i2
            local choiceUIDNew = pageUIDNewPrepend .. i2

            moveColorUser( choiceGradientColorsLookup, choice.gradientColorStr, choiceUID, choiceUIDNew )
            moveColorUser( choiceBandColorsLookup, choice.bandColorStr, choiceUID, choiceUIDNew )
            moveColorUser( choiceNameColorsLookup, choice.nameColorStr, choiceUID, choiceUIDNew )
        end
    end
end

nudgeColorUsers = function( page, pageUID, indStart, indEnd, dir )
    local pageUIDPrepend = pageUID .. "_"
    local polyStr = page.polyStr

    if polyStr then
        removePolyUser( pageUID, polyStr )
        page.polyStr = nil -- Invalidate polyStr; build it later when drawn.
    end

    for i = indStart, indEnd do
        local choice = page[i]
        local choiceUID = pageUIDPrepend .. i
        local choiceUIDNew = pageUIDPrepend .. ( i + dir )

        moveColorUser( choiceGradientColorsLookup, choice.gradientColorStr, choiceUID, choiceUIDNew )
        moveColorUser( choiceBandColorsLookup, choice.bandColorStr, choiceUID, choiceUIDNew )
        moveColorUser( choiceNameColorsLookup, choice.nameColorStr, choiceUID, choiceUIDNew )
    end
end

editChoice = function(
        page, pageUIDPrepend, choiceInd, choice,
        choiceGradientEnabled, choiceBandEnabled,
        choiceGradientColorUnhovered,
        choiceGradientColorHovered,
        choiceBandColorUnhovered,
        choiceBandColorHovered,
        choiceNameColorUnhovered,
        choiceNameColorHovered
    )

    -- This is ugly and bad for maintenance, but great for performance.
    if choiceBandEnabled == nil then
        local menu = choiceGradientEnabled

        choiceGradientEnabled = menu:isChoiceGradientEnabled()
        choiceBandEnabled = menu:isChoiceBandEnabled()
        choiceGradientColorUnhovered = menu._choiceGradientColorUnhovered
        choiceGradientColorHovered = menu._choiceGradientColorHovered
        choiceBandColorUnhovered = menu._choiceBandColorUnhovered
        choiceBandColorHovered = menu._choiceBandColorHovered
        choiceNameColorUnhovered = menu._choiceNameColorUnhovered
        choiceNameColorHovered = menu._choiceNameColorHovered
    end

    local realChoice = page[choiceInd]
    local choiceUID = pageUIDPrepend .. choiceInd
    local gradientEnabled = choice.gradientEnabled
    local bandEnabled = choice.bandEnabled

    if gradientEnabled == nil then
        gradientEnabled = choiceGradientEnabled
    end

    if bandEnabled == nil then
        bandEnabled = choiceBandEnabled
    end

    local name = choice.name

    realChoice.name = name
    realChoice.command = choice.command
    realChoice.menu = choice.menu
    realChoice.menuPageInd = choice.menuPageInd
    realChoice.func = choice.func
    realChoice.paint = choice.paint
    realChoice.paintRadial = choice.paintRadial
    realChoice.gradientEnabled = gradientEnabled
    realChoice.bandEnabled = bandEnabled

    if string.find( name, "\n" ) then
        realChoice.nameLines = string.split( name, "\n" )
    else
        realChoice.nameLines = nil
    end

    local gradientColorStrOld = realChoice.gradientColorStr
    local bandColorStrOld = realChoice.bandColorStr
    local nameColorStrOld = realChoice.nameColorStr

    gradientColorStr = addColorUser( choiceGradientColorsLookup, choiceUID, choice.gradientColorUnhovered or choiceGradientColorUnhovered, choice.gradientColorHovered or choiceGradientColorHovered )
    bandColorStr = addColorUser( choiceBandColorsLookup, choiceUID, choice.bandColorUnhovered or choiceBandColorUnhovered, choice.bandColorHovered or choiceBandColorHovered )
    nameColorStr = addColorUser( choiceNameColorsLookup, choiceUID, choice.nameColorUnhovered or choiceNameColorUnhovered, choice.nameColorHovered or choiceNameColorHovered )

    if gradientColorStrOld and gradientColorStrOld ~= gradientColorStr then
        removeColorUser( choiceGradientColorsLookup, choiceUID, gradientColorStrOld )
    end

    if bandColorStrOld and bandColorStrOld ~= bandColorStr then
        removeColorUser( choiceBandColorsLookup, choiceUID, bandColorStrOld )
    end

    if nameColorStrOld and nameColorStrOld ~= nameColorStr then
        removeColorUser( choiceNameColorsLookup, choiceUID, nameColorStrOld )
    end

    realChoice.gradientColorStr = gradientColorStr
    realChoice.bandColorStr = bandColorStr
    realChoice.nameColorStr = nameColorStr

    if not realChoice._hoverProgress then
        realChoice._hoverProgress = 0
    end
end

validatePolyUser = function( menu, page, pageInd )
    local radiusHovered = menu._radiusHovered
    local radiusUnhovered = menu._radiusUnhovered
    local radiusInnerUnhovered = menu._radiusInnerUnhovered
    local radiusInnerHovered = menu._radiusInnerHovered
    local bandHeight = menu._bandHeight
    local choiceGap = menu._choiceGap

    local pageUID = menu:getName() .. "_" .. pageInd
    local polyStr = addPolyUser( pageUID, radiusHovered, radiusUnhovered, radiusInnerUnhovered, radiusInnerHovered, bandHeight, choiceGap, #page )

    page.polyStr = polyStr

    return polyStr
end

handleChoiceClick = function()
    local curPageInd = curMenu:getCurPageInd()
    local choice = curMenu._pages[curPageInd][hoveredInd]
    local command = choice.command
    local targetMenuName = choice.menu
    local func = choice.func

    hook.run( "LKL_RadialMenu_ChoiceClicked", curMenu, curPageInd, hoveredInd )

    if command and player() == owner() then
        concmd( command )
    elseif targetMenuName then
        local targetMenu = menusByName[targetMenuName]

        if targetMenu then
            local prev = curMenu
            local pageInd = choice.menuPageInd

            hook.run( "LKL_RadialMenu_OnOpenedSubmenu", prev, targetMenu, pageInd )
            targetMenu:open( pageInd )
        else
            error( "Couldn't find a RadialMenu with the name of " .. targetMenuName )
        end
    elseif func then
        func( curMenu, curMenu:getCurPageInd(), hoveredInd )
    end
end

resetHoverProgress = function( menu )
    local page = menu._pages[menu:getCurPageInd()]

    for i = 1, #page do
        local choice = page[i]
        choice._hoverProgress = 0
    end
end

getColorEff = function( menu, pageInd, choiceInd, hoverProgress, lookup, storedName, colorStrName )
    local choice = menu._pages[pageInd][choiceInd]

    if not hoverProgress then
        local color = choice[storedName]
        if color then return color end

        hoverProgress = choice._hoverProgress -- Choice has yet to be rendered.
    end

    local frameInd = math.floor( hoverProgress * CHOICE_FRAME_COUNT )

    return getColorFrame( lookup, choice[colorStrName], frameInd )
end


----- SETUP -----

local memVec = Vector() -- Intermediate vector for calculations to create less garbage memory.
local memVecScale = Vector( 1 )
local memAng = Angle()

hook.add( "DrawHUD", "LKL_RadialMenu_DrawCurrentMenu", function()
    if not permissionSatisfied then return end
    if not curMenu then return end

    render.setFont( mainFont )

    if cpuTotalAverage() > cpuMax() * PERF_LIMIT then
        local cvarName = player() == owner() and "sf_timebuffer_cl_owner" or "sf_timebuffer_cl"

        render.setRGBA( 255, 0, 0, 255 )
        render.drawSimpleText( scrW / 2, scrH / 2, "Failed to draw radial menu", TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        render.drawSimpleText( scrW / 2, scrH / 2 + mainFontSizeEff, "Please increase " .. cvarName, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

        return
    end

    render.pushMatrix( matrCenter )

    local nameAlign = curMenu:getNameAlign()
    local menuNameY = 0
    local menuRadius = curMenu:getRadiusEff()

    if nameAlign == TEXT_ALIGN_TOP then
        menuNameY = -menuRadius - curMenu:getNameOffset() * scrH
    elseif nameAlign == TEXT_ALIGN_BOTTOM then
        menuNameY = menuRadius + curMenu:getNameOffset() * scrH
    end

    -- Draw menu name
    local m = Matrix()
    memVec[2] = menuNameY
    m:translate( memVec )
    m:scale( VECTOR_MENU_NAME_SCALE )

    render.pushMatrix( m )
    render.setRGBA( 255, 255, 255, 255 )
    render.drawSimpleText( 0, 0, curMenu:getDisplayName(), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    render.popMatrix()

    -- Draw page number and count
    m = Matrix()
    memVec[2] = menuNameY + pageNumOffsetY
    m:translate( memVec )
    m:scale( VECTOR_PAGE_NAME_SCALE )

    local curPageInd = curMenu:getCurPageInd()

    render.pushMatrix( m )
    render.drawSimpleText( 0, 0, "Page " .. curPageInd .. " / " .. curMenu:getPageCount(), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    render.popMatrix()

    local pages = curMenu._pages
    local curPage = pages[curPageInd]
    local pageName = curPage.name

    -- Draw page name
    if pageName then
        m = Matrix()
        memVec[2] = menuNameY + pageNameOffsetY
        m:translate( memVec )
        m:scale( VECTOR_PAGE_NAME_SCALE )

        render.pushMatrix( m )
        render.drawSimpleText( 0, 0, pageName, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        render.popMatrix()
    end

    local polyStr = curPage.polyStr

    -- Add poly users here instead of immediately on page creation/adjustment in case multiple operations are done in one frame.
    if not polyStr then
        polyStr = validatePolyUser( curMenu, curPage, curPageInd )
    end

    local degStep = 360 / #curPage
    local hoverDT = timer.frametime() / curMenu:getHoverDuration()
    local polySetsByFrame = choicePolySetsLookup[polyStr]
    local choiceGradientPolys = polySetsByFrame.gradientPolys
    local choiceBandPolys = polySetsByFrame.bandPolys
    local choiceNameRadii = polySetsByFrame.nameRadii
    local arcWidthMult = math.pi * 2 / #curPage

    local menuFont = curMenu._fontObj
    local menuFontVecScale = curMenu._fontVecScale
    local menuFontHeight = curMenu._fontSizeEff
    local menuFontScale = menuFontVecScale[1]
    local bandHeight = curMenu._bandHeight
    local nameLineSpacing = 10 * scrH / 1080

    local matrChoice = Matrix()
    memAng[2] = degStep

    -- Draw choices
    for i, choice in ipairs( curPage ) do
        local deg = ( i - 1 ) * degStep
        local hoverProgress = choice._hoverProgress

        if i == hoveredInd then
            hoverProgress = math.min( hoverProgress + hoverDT, 1 )
        else
            hoverProgress = math.max( hoverProgress - hoverDT, 0 )
        end

        choice._hoverProgress = hoverProgress
        local frameInd = math.round( hoverProgress * CHOICE_FRAME_COUNT )
        local gradientPoly = choiceGradientPolys[frameInd]

        if not gradientPoly then
            makePolyFrame( polySetsByFrame, frameInd )
            gradientPoly = choiceGradientPolys[frameInd]
        end

        render.pushMatrix( matrChoice )

        local gradientColorEff = getColorFrame( choiceGradientColorsLookup, choice.gradientColorStr, frameInd )
        choice._gradientColorEff = gradientColorEff
        render.setMaterial( choice.gradientEnabled and matGradient or nil )
        render.setColor( gradientColorEff )
        render.drawPoly( gradientPoly )

        if choice.bandEnabled then
            local bandColorEff = getColorFrame( choiceBandColorsLookup, choice.bandColorStr, frameInd )
            choice._bandColorEff = bandColorEff
            render.setMaterial()
            render.setColor( bandColorEff )
            render.drawPoly( choiceBandPolys[frameInd] )
        end

        local nameColorEff = getColorFrame( choiceNameColorsLookup, choice.nameColorStr, frameInd )
        choice._nameColorEff = nameColorEff
        render.setFont( menuFont )
        render.setColor( nameColorEff )

        local matrText = Matrix()
        local nameRadius = choiceNameRadii[frameInd]
        memVec[2] = -nameRadius
        matrText:translate( memVec )

        if deg > 90 and deg < 270 then
            matrText:rotate( Angle( 0, 180, 0 ) )
        end

        matrText:scale( menuFontVecScale )

        local nameLines = choice.nameLines
        local textWidthLimit = nameRadius * arcWidthMult * 0.85

        if nameLines then -- Multiline name
            local textWidthMax = 0
            local lineCount = #nameLines

            for _, line in ipairs( nameLines ) do
                local textWidth = render.getTextSize( line ) * menuFontScale

                if textWidth > textWidthMax then
                    textWidthMax = textWidth
                end
            end

            local textHeight = menuFontHeight * lineCount + ( lineCount - 1 ) * nameLineSpacing
            local textHeightLimit = bandHeight * 0.95
            local textMultMax = math.max( textWidthMax / textWidthLimit, textHeight / textHeightLimit )

            if textMultMax > 1 then
                local textScale = 1 / textMultMax

                memVecScale[1] = textScale
                memVecScale[2] = textScale
                matrText:scale( memVecScale )
            end

            local y = -textHeight * ( ( lineCount - 1 ) / 2 ) / lineCount
            local yStep = menuFontHeight + nameLineSpacing

            render.pushMatrix( matrText )

            for _, line in ipairs( nameLines ) do
                render.drawSimpleText( 0, y, line, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
                y = y + yStep
            end

            render.popMatrix()
        else -- One-line name
            local name = choice.name
            local textWidth = render.getTextSize( name ) * menuFontScale

            -- Resize text that's a bit too big to fit.
            if textWidth > textWidthLimit then
                local textScale = textWidthLimit / textWidth

                memVecScale[1] = textScale
                memVecScale[2] = textScale
                matrText:scale( memVecScale )
            end

            render.pushMatrix( matrText )
            render.drawSimpleText( 0, 0, name, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            render.popMatrix()
        end

        local paintRadial = choice.paintRadial

        if paintRadial then
            paintRadial( nameRadius + bandHeight / 2, bandHeight, i == hoveredInd, curMenu, curPageInd, i, hoverProgress )
        end

        render.popMatrix() -- matrChoice

        matrChoice:rotate( memAng )

        local paint = choice.paint

        if paint then
            local rad = math.rad( deg + 90 )
            local xDir = -math.cos( rad )
            local yDir = -math.sin( rad )

            paint( xDir, yDir, nameRadius + bandHeight / 2, bandHeight, i == hoveredInd, curMenu, curPageInd, i, hoverProgress )
        end
    end

    render.popMatrix() -- matrCenter
end )

hook.add( "think", "LKL_RadialMenu_TrackMouse", function()
    if not permissionSatisfied then return end
    if not curMenu then return end

    if not input.getCursorVisible() then
        hoveredInd = nil

        return
    end

    local x, y = input.getCursorPos()
    x = x - scrW / 2
    y = y - scrH / 2

    local radius = math.sqrt( x * x + y * y )

    if radius <= curMenu:getDeadzoneRadiusEff() then
        hoveredInd = false -- False for if we have had time to detect a deadzone hover, nil for we have no idea.

        return
    end

    local rad = math.asin( y / radius )
    local choiceCount = curMenu:getCurPageChoiceCount()
    local radPerChoice = 2 * MATH_PI / choiceCount

    rad = rad + MATH_PI / 2

    if x < 0 then
        rad = 2 * MATH_PI - rad
    end

    local nearestMult = math.nearestMultiple( rad, radPerChoice )

    hoveredInd = 1 + math.round( nearestMult / radPerChoice ) % choiceCount
end )

hook.add( "inputPressed", "LKL_RadialMenu_Input", function( key )
    if not curMenu then return end
    if not isFirstTimePredicted() then return end
    if not permissionSatisfied then return end

    if key == MOUSE.LEFT then
        if hoveredInd then
            handleChoiceClick()
        elseif hoveredInd == false and curMenu:getPageCount() > 1 then
            -- Previous page
            curMenu:setCurPageInd( ( curMenu:getCurPageInd() - 2 ) % curMenu:getPageCount() + 1 )
        end
    elseif key == MOUSE.RIGHT then
        if hoveredInd == false then
            if curMenu:getPageCount() > 1 then
                -- Next page
                curMenu:setCurPageInd( ( curMenu:getCurPageInd() % curMenu:getPageCount() ) + 1 )
            end
        elseif hoveredInd then
            hook.run( "LKL_RadialMenu_InputPressed", curMenu, key )
        end
    else
        hook.run( "LKL_RadialMenu_InputPressed", curMenu, key )
    end
end )
