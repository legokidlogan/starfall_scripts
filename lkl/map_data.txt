--@name Map Data
--@author legokidlogan
--@shared
--@include lkl/global_data_manager.txt
--@include lkl/gcolors.txt

libMapData = libMapData or {}

if libMapData._alreadyRequired then return end
libMapData._alreadyRequired = true


-- CONFIG:
libMapData.OWNER_ONLY = libMapData.OWNER_ONLY or false -- If true, then the owner will be the only client to receive map data.
-- END CONFIG


require( "lkl/gcolors.txt" )

local dataIsReady = false
local versionID = "v1"
local hasSentReadyHook = false
local acknowledgementTimeout = 5


----- GLOBAL FUNCTIONS -----

--[[
    - Whether or not the map's data has been loaded/generated yet and is ready to be used.
    - Upon data becoming ready, server and client will run the LKL_MapData_DataReady hook.
--]]
function libMapData.isDataReady()
    return dataIsReady
end

--[[
    - Returns the map's data, or nil if it isn't ready yet.
    - This returns by reference, so DO NOT MODIFY IT.
    - Data is of the following format: {
        Center = VECTOR,
        MinBounds = VECTOR,
        MaxBounds = VECTOR,
        SpawnPoints = {
            [1] = {
                Pos = VECTOR,
                Ang = ANGLE,
            },
            ...
        },
        PlayableRegion = {
            Center = VECTOR,
            MinBounds = VECTOR,
            MaxBounds = VECTOR,
        },
        Skybox = false or { -- false if no 3D skybox
            Center = VECTOR,
            MinBounds = VECTOR,
            MaxBounds = VECTOR,
        },
    }
--]]
function libMapData.getData()
    if not dataIsReady then return end

    return data
end

function libMapData.getVersionID()
    return versionID
end


----- NON-OWNER DATA RECEIVING -----

if CLIENT and player() ~= owner() then
    net.receive( "LKL_MapData_SendData_NonOwner", function()
        net.readStream( function( str )
            data = json.decode( str )
            dataIsReady = true

            hook.run( "LKL_MapData_DataReady" )
        end )
    end )


    return
end


----- DATA STORAGE -----

if CLIENT then
    local dataFilePath = "lkl/map_data/" .. string.lower( game.getMap() ) .. ".txt"


    local function requestDataGeneration()
        net.start( "LKL_MapData_GenerateData" )
        net.send()
    end

    local function tryLoadData()
        timer.remove( "LKL_MapData_TryLoad" )

        if not file.exists( dataFilePath ) then
            requestDataGeneration()

            return
        end

        local fileData = json.decode( file.read( dataFilePath ) )
        fileData = fileData[versionID]

        if fileData == nil then
            requestDataGeneration()

            return
        end

        data = fileData
        dataIsReady = true

        net.start( "LKL_MapData_SendData" )
        net.writeStream( json.encode( data ), false )
        net.send()

        timer.simple( acknowledgementTimeout, function()
            if hasSentReadyHook then return end

            hook.run( "LKL_MapData_DataReady" )
        end )
    end


    net.receive( "LKL_MapData_DataReceived", function()
        if hasSentReadyHook then return end

        hasSentReadyHook = true
        hook.run( "LKL_MapData_DataReady" )
    end )

    net.receive( "LKL_MapData_SendData", function()
        net.readStream( function( str )
            data = json.decode( str )
            dataIsReady = true

            local fileData

            if file.exists( dataFilePath ) then
                fileData = json.decode( file.read( dataFilePath ) )
            else
                fileData = {}
            end

            fileData[versionID] = data
            file.write( dataFilePath, json.encode( fileData ) )

            net.start( "LKL_MapData_DataReceived" )
            net.send()

            print(
                c_white, "[MapData] ",
                c_pale_green, "Newly-generated data has been saved!"
            )

            hasSentReadyHook = true
            hook.run( "LKL_MapData_DataReady" )
        end )
    end )

    net.receive( "LKL_MapData_TryLoadData", function()
        tryLoadData()
    end )


    do
        local folder = string.getPathFromFilename( dataFilePath )
        file.createDir( folder )

        if libMapData.OWNERONLY then
            tryLoadData()
        else
            timer.create( "LKL_MapData_TryLoad", 3, 0, tryLoadData ) -- Delay in case other players have bad ping
        end
    end


    return
end


----- DATA GENERATION -----

local finishGeneratingData


local TRACE_LENGTH = 50000
local TRACE_COLLISION_GROUP = COLLISION_GROUP.DEBRIS
local TRACE_MASK = MASK.SOLID_BRUSHONLY
local BOUNCE_OFFSETS = {
    Vector( 1, 1, 1 ):getNormalized() * TRACE_LENGTH,
    Vector( 1, 1, -1 ):getNormalized() * TRACE_LENGTH,
    Vector( 1, -1, 1 ):getNormalized() * TRACE_LENGTH,
    Vector( 1, -1, -1 ):getNormalized() * TRACE_LENGTH,
    Vector( -1, 1, 1 ):getNormalized() * TRACE_LENGTH,
    Vector( -1, 1, -1 ):getNormalized() * TRACE_LENGTH,
    Vector( -1, -1, 1 ):getNormalized() * TRACE_LENGTH,
    Vector( -1, -1, -1 ):getNormalized() * TRACE_LENGTH,
}

local perfLimitFrac = 0.5
local iterationInterval = 0.1

local playableRegionBouncesPerChain = 400

local skyboxBouncesPerChain = 20

local mapMinX = math.huge
local mapMinY = math.huge
local mapMinZ = math.huge
local mapMaxX = -math.huge
local mapMaxY = -math.huge
local mapMaxZ = -math.huge
local mapBrushSurfaces = nil
local mapBrushSurfaceInd = 1
local mapBrushSurfaceCount = 0
local gettingMapBounds = false

local playableRegionMinX = math.huge
local playableRegionMinY = math.huge
local playableRegionMinZ = math.huge
local playableRegionMaxX = -math.huge
local playableRegionMaxY = -math.huge
local playableRegionMaxZ = -math.huge
local tracingPlayableRegion = false
local playableRegionBouncesRemaining = nil
local playableRegionBounceOrigins = {}
local playableRegionBounceOffsets = {}
local playableRegionBounceLastPos = nil
local playableRegionBounceLastOffset = nil

local skyboxMinX = math.huge
local skyboxMinY = math.huge
local skyboxMinZ = math.huge
local skyboxMaxX = -math.huge
local skyboxMaxY = -math.huge
local skyboxMaxZ = -math.huge
local tracingSkybox = false
local skyboxBouncesRemaining = nil
local skyboxBounceOrigins = {}
local skyboxBounceOffsets = {}
local skyboxBounceLastPos = nil
local skyboxBounceLastOffset = nil

local tableInsert = table.insert
local tableRemove = table.remove
local traceLine = trace.line


local function getPerfLimit()
    local perfLimit = cpuMax() * perfLimitFrac
    local totalPerf = cpuTotalAverage()
    if totalPerf >= perfLimit then return end

    local otherPerf = totalPerf - cpuAverage()
    perfLimit = perfLimit - otherPerf

    return perfLimit
end

local function mapTraceSingleBounce( pos, offset )
    local tr = traceLine( pos, pos + offset, nil, TRACE_COLLISION_GROUP, TRACE_MASK, false )
    if tr.StartSolid then return false end

    if tr.Hit then
        local newOffset = -offset:rotateAroundAxis( tr.HitNormal, 180 )

        return tr.HitPos, newOffset
    end

    return tr.HitPos, offset
end

local function expandPlayableRegion( pos )
    local x = pos[1]
    local y = pos[2]
    local z = pos[3]

    if x < playableRegionMinX then
        playableRegionMinX = x
    elseif x > playableRegionMaxX then
        playableRegionMaxX = x
    end

    if y < playableRegionMinY then
        playableRegionMinY = y
    elseif y > playableRegionMaxY then
        playableRegionMaxY = y
    end

    if z < playableRegionMinZ then
        playableRegionMinZ = z
    elseif z > playableRegionMaxZ then
        playableRegionMaxZ = z
    end
end

local function expandSkybox( pos )
    local x = pos[1]
    local y = pos[2]
    local z = pos[3]

    if x < skyboxMinX then
        skyboxMinX = x
    elseif x > skyboxMaxX then
        skyboxMaxX = x
    end

    if y < skyboxMinY then
        skyboxMinY = y
    elseif y > skyboxMaxY then
        skyboxMaxY = y
    end

    if z < skyboxMinZ then
        skyboxMinZ = z
    elseif z > skyboxMaxZ then
        skyboxMaxZ = z
    end
end

local function addOriginToPlayableRegionBounces( origin )
    if not origin:isInWorld() then return end

    for _, offset in ipairs( BOUNCE_OFFSETS ) do
        tableInsert( playableRegionBounceOrigins, origin )
        tableInsert( playableRegionBounceOffsets, offset )
    end
end

local function addOriginToSkyboxBounces( origin )
    if not origin:isInWorld() then return end

    for _, offset in ipairs( BOUNCE_OFFSETS ) do
        tableInsert( skyboxBounceOrigins, origin )
        tableInsert( skyboxBounceOffsets, offset )
    end
end

local function startGettingMapBounds()
    print(
        c_white, "[MapData] ",
        c_pend_orange, "Getting map bounds..."
    )

    gettingMapBounds = true
    mapBrushSurfaces = game.getWorld():getBrushSurfaces() -- TODO: Verify whether this starts at 0 or 1
    mapBrushSurfaceInd = 1
    mapBrushSurfaceCount = #mapBrushSurfaces
end

local function startGettingPlayableRegion()
    if not tracingPlayableRegion then
        print(
            c_white, "[MapData] ",
            c_pend_orange, "Tracing playable region..."
        )
    end

    tracingPlayableRegion = true
    playableRegionBouncesRemaining = playableRegionBouncesPerChain
    playableRegionBounceLastPos = tableRemove( playableRegionBounceOrigins )
    playableRegionBounceLastOffset = tableRemove( playableRegionBounceOffsets )

    if not playableRegionBounceLastPos then
        error( "Map has no info_player_start or env_soundscape* entities!" )
    end
end

local function startGettingSkybox()
    if not tracingSkybox then
        print(
            c_white, "[MapData] ",
            c_pend_orange, "Tracing skybox..."
        )
    end

    local skyCam = find.byClass( "sky_camera" )[1]
    skyCam = isValid( skyCam ) and skyCam

    if skyCam then
        addOriginToSkyboxBounces( skyCam:getPos() )
    end

    if not skyCam or #skyboxBounceOrigins == 0 then
        print(
            c_white, "[MapData] ",
            alert_red, "Couldn't find a ",
            c_yellow, "sky_camera ",
            alert_red, "entity! This map likely has no skybox."
        )

        data.Skybox = false
        startGettingPlayableRegion()

        return
    end

    tracingSkybox = true
    skyboxBouncesRemaining = skyboxBouncesPerChain
    skyboxBounceLastPos = tableRemove( skyboxBounceOrigins )
    skyboxBounceLastOffset = tableRemove( skyboxBounceOffsets )
end


timer.create( "LKL_MapData_GetMapBounds", iterationInterval, 0, function()
    if not gettingMapBounds then return end

    local perfLimit = getPerfLimit()
    if not perfLimit then return end

    while mapBrushSurfaceInd <= mapBrushSurfaceCount and cpuAverage() < perfLimit do
        local verts = mapBrushSurfaces[mapBrushSurfaceInd]:getVertices()

        for _, vert in ipairs( verts ) do
            local x = vert[1]
            local y = vert[2]
            local z = vert[3]

            if x < mapMinX then
                mapMinX = x
            elseif x > mapMaxX then
                mapMaxX = x
            end

            if y < mapMinY then
                mapMinY = y
            elseif y > mapMaxY then
                mapMaxY = y
            end

            if z < mapMinZ then
                mapMinZ = z
            elseif z > mapMaxZ then
                mapMaxZ = z
            end
        end

        mapBrushSurfaceInd = mapBrushSurfaceInd + 1
    end

    if mapBrushSurfaceInd > mapBrushSurfaceCount then
        local mapMin = Vector( mapMinX, mapMinY, mapMinZ )
        local mapMax = Vector( mapMaxX, mapMaxY, mapMaxZ )

        data.Center = ( mapMin + mapMax ) / 2
        data.MinBounds = mapMin
        data.MaxBounds = mapMax

        gettingMapBounds = false
        timer.remove( "LKL_MapData_GetMapBounds" )
        finishGeneratingData()
    end
end )

timer.create( "LKL_MapData_TracePlayableRegion", iterationInterval, 0, function()
    if not tracingPlayableRegion then return end

    local perfLimit = getPerfLimit()
    if not perfLimit then return end

    while cpuAverage() < perfLimit do
        for _ = 1, 10 do -- Trace more times per each perf check, improving speed but increasing risk of breaching perf
            if playableRegionBouncesRemaining <= 0 then
                playableRegionBouncesRemaining = playableRegionBouncesPerChain
                playableRegionBounceLastPos = tableRemove( playableRegionBounceOrigins )
                playableRegionBounceLastOffset = tableRemove( playableRegionBounceOffsets )

                if not playableRegionBounceLastPos then
                    local playableRegionMin = Vector( playableRegionMinX, playableRegionMinY, playableRegionMinZ )
                    local playableRegionMax = Vector( playableRegionMaxX, playableRegionMaxY, playableRegionMaxZ )

                    data.PlayableRegion = {
                        Center = ( playableRegionMin + playableRegionMax ) / 2,
                        MinBounds = playableRegionMin,
                        MaxBounds = playableRegionMax,
                    }

                    tracingPlayableRegion = false
                    timer.remove( "LKL_MapData_TracePlayableRegion" )
                    startGettingMapBounds()

                    return
                end
            end

            local nextPos, nextOffset = mapTraceSingleBounce( playableRegionBounceLastPos, playableRegionBounceLastOffset )
            if not nextPos then
                playableRegionBouncesRemaining = 0

                break
            end

            expandPlayableRegion( nextPos )
            playableRegionBounceLastPos = nextPos
            playableRegionBounceLastOffset = nextOffset
            playableRegionBouncesRemaining = playableRegionBouncesRemaining - 1
        end
    end
end )

timer.create( "LKL_MapData_TraceSkybox", iterationInterval, 0, function()
    if not tracingSkybox then return end

    local perfLimit = getPerfLimit()
    if not perfLimit then return end

    while cpuAverage() < perfLimit do
        for _ = 1, 10 do -- Trace more times per each perf check, improving speed but increasing risk of breaching perf
            if skyboxBouncesRemaining == 0 then
                skyboxBouncesRemaining = skyboxBouncesPerChain
                skyboxBounceLastPos = tableRemove( skyboxBounceOrigins )
                skyboxBounceLastOffset = tableRemove( skyboxBounceOffsets )

                if not skyboxBounceLastPos then
                    local skyboxMin = Vector( skyboxMinX, skyboxMinY, skyboxMinZ )
                    local skyboxMax = Vector( skyboxMaxX, skyboxMaxY, skyboxMaxZ )

                    data.Skybox = {
                        Center = ( skyboxMin + skyboxMax ) / 2,
                        MinBounds = skyboxMin,
                        MaxBounds = skyboxMax,
                    }

                    tracingSkybox = false
                    timer.remove( "LKL_MapData_TraceSkybox" )
                    startGettingPlayableRegion()

                    return
                end
            end

            local nextPos, nextOffset = mapTraceSingleBounce( skyboxBounceLastPos, skyboxBounceLastOffset )
            if not nextPos then break end

            expandSkybox( nextPos )
            skyboxBounceLastPos = nextPos
            skyboxBounceLastOffset = nextOffset
            skyboxBouncesRemaining = skyboxBouncesRemaining - 1
        end
    end
end )


local function generateMapData()
    print(
        c_white, "[MapData] ",
        c_pend_orange, "Generating ",
        c_yellow, tostring( versionID ),
        c_pend_orange, " map data..."
    )

    data = {}

    -- Find spawn points
    print(
        c_white, "[MapData] ",
        c_pend_orange, "Getting spawn points..."
    )

    local spawnPoints = find.byClass( "info_player_start" )
    local spawnPointDatas = {}

    data.SpawnPoints = spawnPointDatas

    for _, spawnPoint in ipairs( spawnPoints ) do
        local pos = spawnPoint:getPos()
        local ang = spawnPoint:getAngles()

        expandPlayableRegion( pos )
        addOriginToPlayableRegionBounces( pos )

        tableInsert( spawnPointDatas, {
            Pos = pos,
            Ang = ang,
        } )
    end

    -- Use a subset of the soundscape entities to get more bounce origins, in case the spawn points are in a separate, teleport-only area.
    local soundscapeEnts = find.byClass( "env_soundscape*" )

    for i = 1, math.min( #soundscapeEnts, 20 ) do
        local soundscapeEnt = soundscapeEnts[i]
        local pos = soundscapeEnt:getPos()

        expandPlayableRegion( pos )
        addOriginToPlayableRegionBounces( pos )
    end

    startGettingSkybox()
end


----- DATA MANAGEMENT -----

require( "lkl/global_data_manager.txt" )

local generatingData = false
local waitingToGenerateData = false


local function getWaitingChips()
    local results = hookRunRemoteByOwner( owner(), "LKL_MapData_IsWaitingToGenerateData" )
    local chips = {}

    for _, resultArgs in ipairs( results ) do
        local chipEnt = resultArgs.Chip

        if chipEnt ~= chip() and resultArgs[1] == true then
            table.insert( chips, chipEnt )
        end
    end

    return chips
end

local function isOtherChipGenerating( otherChip )
    local generatingChipInfo = GDM.OwnerData.MapData.GeneratingChipInfo
    if not generatingChipInfo then return false end

    if generatingChipInfo.EntIndex == otherChip:entIndex() then return true end
    if generatingChipInfo.CreationID == otherChip:getCreationID() then return true end
    if generatingChipInfo.CreationTime == math.floor( otherChip:getCreationTime() ) then return true end

    return false
end

local function canGenerateData()
    local generatingChipInfo = GDM.OwnerData.MapData.GeneratingChipInfo
    if not generatingChipInfo then return true end

    return isOtherChipGenerating( chip() )
end

local function markAsGeneratingChip( otherChip )
    GDM.OwnerData.MapData.GeneratingChipInfo = {
        EntIndex = otherChip:entIndex(),
        CreationID = otherChip:getCreationID(),
        CreationTime = math.floor( otherChip:getCreationTime() ),
    }

    GDM.pushOwnerData()
end

local function unmarkGeneratingChip()
    GDM.OwnerData.MapData.GeneratingChipInfo = nil
    GDM.pushOwnerData()
end

local function sendDataToNonOwners()
    if libMapData.OWNER_ONLY then return end

    local allButOwner = find.allPlayers( function( ply )
        return ply ~= owner()
    end )

    net.start( "LKL_MapData_SendData_NonOwner" )
    net.writeStream( json.encode( data ), false )
    net.send( allButOwner )
end

local function allowNextChipToGetData()
    if not isOtherChipGenerating( chip() ) then return end

    local otherChips = getWaitingChips()
    local otherChip = otherChips[1]

    if isValid( otherChip ) then
        markAsGeneratingChip( otherChip )
        hookRunRemoteFixed( otherChip, "LKL_MapData_StartGettingData", versionID, data )
    else
        unmarkGeneratingChip()
    end
end

finishGeneratingData = function()
    generatingData = false
    dataIsReady = true

    print(
        c_white, "[MapData] ",
        c_pale_green, "Data generated! ",
        c_pend_orange, "Saving data..."
    )

    net.start( "LKL_MapData_SendData" )
    net.writeStream( json.encode( data ), false )
    net.send()

    sendDataToNonOwners()

    timer.simple( acknowledgementTimeout, function()
        if hasSentReadyHook then return end

        hasSentReadyHook = true
        hook.run( "LKL_MapData_DataReady" )
        allowNextChipToGetData()
    end )
end

local function startGeneratingData()
    if generatingData then return end
    if dataIsReady then return end

    if not canGenerateData() then
        waitingToGenerateData = true

        return
    end

    generatingData = true
    waitingToGenerateData = false
    markAsGeneratingChip( chip() )

    generateMapData()
end


hook.add( "EntityRemoved", "LKL_MapData_BecomeGeneratingChip", function( ent )
    if not waitingToGenerateData then return end
    if not ent then return end
    if ent:getClass() ~= "starfall_processor" then return end
    if ent:getOwner() ~= owner() then return end
    if not isOtherChipGenerating( ent ) then return end

    unmarkGeneratingChip()
    startGeneratingData()
end )

hook.add( "StarfallError", "LKL_MapData_BecomeGeneratingChip", function( otherChip, otherOwner )
    if not waitingToGenerateData then return end
    if not isValid( otherChip ) then return end
    if otherOwner ~= owner() then return end
    if not isOtherChipGenerating( otherChip ) then return end

    unmarkGeneratingChip()
    startGeneratingData()
end )

hook.add( "Removed", "LKL_MapData_AllowNextChipToGetData", function()
    allowNextChipToGetData()
end )


hook.add( "Remote_LKL_MapData_IsWaitingToGenerateData", "LKL_MapData_Response", function( _callingChip, callingPly )
    if callingPly ~= owner() then return end

    if waitingToGenerateData then
        return true
    end
end )

hook.add( "Remote_LKL_MapData_StartGettingData", "LKL_MapData_LoadOrGenerateData", function( _callingChip, callingPly, otherVersionID, otherData )
    if callingPly ~= owner() then return end
    if not waitingToGenerateData then return end

    waitingToGenerateData = false

    if otherVersionID == versionID then
        data = otherData
        finishGeneratingData()
    else
        -- Try reloading the data from the owner's client, in case it has changed. If it's not in the file, then we'll generate it like normal.
        net.start( "LKL_MapData_TryLoadData" )
        net.send( owner() )
    end
end )


net.receive( "LKL_MapData_GenerateData", function( _, ply )
    if ply ~= owner() then return end

    startGeneratingData()
end )

net.receive( "LKL_MapData_DataReceived", function( _, ply )
    if ply ~= owner() then return end
    if hasSentReadyHook then return end

    hasSentReadyHook = true
    hook.run( "LKL_MapData_DataReady" )
    allowNextChipToGetData()
end )

net.receive( "LKL_MapData_SendData", function( _, ply )
    if ply ~= owner() then return end

    net.readStream( function( str )
        data = json.decode( str )
        dataIsReady = true
        generatingData = false
        waitingToGenerateData = false

        net.start( "LKL_MapData_DataReceived" )
        net.send( owner() )

        hasSentReadyHook = true
        hook.run( "LKL_MapData_DataReady" )

        sendDataToNonOwners()
        allowNextChipToGetData()
    end )
end )


do
    local shouldPushGDM = false

    if not GDM.OwnerData.MapData then
        shouldPushGDM = true
        GDM.OwnerData.MapData = {}
    end

    if shouldPushGDM then
        GDM.pushOwnerData()
    end
end
