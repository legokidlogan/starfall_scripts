--@name Prop to Holo Spawner
--@author legokidlogan
--@shared
--@include lkl/queue.txt
--@include lkl/submaterial.txt

if pthSpawner and pthSpawner.spawn then return end

require( "lkl/queue.txt" )
require( "lkl/submaterial.txt" )


pthSpawner = pthSpawner or {}

local COLOR_DEFAULT = Color( 255, 255, 255, 255 )
local RENDER_MODE_DEFAULT = 0

local holoGroups = {}
local holoGroupCallbacks = {}
local holoGroupOrigins = {}
local holoGroupOriginAngles = {}
local holoGroupScales = {}
local holoGroupIncrement = 0
local spawnQueue


--[[
    - Spawns holograms based off of Prop to Holo data.

    pos: (Vector)
        - The origin for the collection of holos.
    ang: (Angle)
        - The angle for the collection of holos.
    dataStr: (string)
        - The PtH data string to use.
        - Files generated by PtH are scripts that return a string, so you can do something like this:
            local myHoloData = require( "myHoloData.txt" )
            pthSpawner.spawn( Vector( 0, 0, 0 ), myHoloData )
    callback: (optional) (function)
        - A function of the form  function( holograms ) end
        - Called when the holograms are done being created.
    scale: (optional) (Vector)
        - An overall scale to apply to all of the holograms.


    RETURNS: groupID
        groupID (number):
            - The ID of the group of holograms.
            - Used to cancel the group from spawning, if needed.
            - Will be nil if the group cannot be spawned, such as if the request is too large for the current hologram limit.
--]]
function pthSpawner.spawn( pos, ang, dataStr, callback, scale )
    if type( pos ) ~= "Vector" then error( "Expected pos to be a Vector" ) end
    if type( ang ) ~= "Angle" then error( "Expected ang to be an Angle" ) end
    if type( dataStr ) ~= "string" then error( "Expected dataStr to be a string" ) end

    if callback == nil then
        callback = function() end
    end

    if type( callback ) ~= "function" then error( "Expected callback to be a function or nil" ) end
    if scale ~= nil and type( scale ) ~= "Vector" then error( "Expected scale to be a Vector or nil" ) end

    local data = json.decode( dataStr )
    local dataCount = #data

    if dataCount + spawnQueue:getLength() > hologram.hologramsLeft() then
        print( "PtH cannot spawn any more holograms!" )

        return
    end

    holoGroupIncrement = holoGroupIncrement + 1
    holoGroups[holoGroupIncrement] = {}
    holoGroupCallbacks[holoGroupIncrement] = callback
    holoGroupOrigins[holoGroupIncrement] = pos
    holoGroupOriginAngles[holoGroupIncrement] = ang
    holoGroupScales[holoGroupIncrement] = scale

    for _, entry in ipairs( data ) do
        entry.GroupID = holoGroupIncrement
    end

    data[dataCount].IsLast = true

    spawnQueue:addEntriesAndStart( data )

    return holoGroupIncrement
end

--[[
    - Cancel an in-progress hologram group.
    - Does nothing if the group has already finished spawning.
    - If you call this from the EntityRemoved hook, be sure to do  holo._isRemoving = true  beforehand to prevent an infinite loop.

    groupID: (number)
        - The ID of the group to cancel.
        - Received from pthSpawner.spawn().
--]]
function pthSpawner.cancel( groupID )
    if type( groupID ) ~= "number" then error( "Expected groupID to be a number" ) end
    if not holoGroups[groupID] then return end

    local holoGroup = holoGroups[groupID]
    local entries = spawnQueue:getEntries()

    for _, holo in ipairs( holoGroup ) do
        if not holo._isRemoving and isValid( holo ) then
            holo:remove()
        end
    end

    for i = #entries, 1, -1 do
        if entries[i].GroupID == groupID then
            spawnQueue:removeEntry( i )
        end
    end

    holoGroups[groupID] = nil
    holoGroupCallbacks[groupID] = nil
    holoGroupOrigins[groupID] = nil
    holoGroupScales[groupID] = nil
end


spawnQueue = Queue:new(
    function( _, entry )
        if not hologram.canSpawn() then return true end -- Retry later

        local groupID = entry.GroupID
        local origin = holoGroupOrigins[groupID]
        local originAng = holoGroupOriginAngles[groupID]
        local overallScale = holoGroupScales[groupID]

        local localPos = entry.Pos
        local scale = entry.Scale

        if overallScale then
            localPos = localPos * overallScale
            scale = ( scale or 1 ) * overallScale
        end

        local holo
        local success = pcall( function()
            local pos, ang = localToWorld( localPos, entry.Ang, origin, originAng )

            holo = hologram.create( pos, ang, entry.Model, scale )
        end )

        if not success then return true end

        local holoGroup = holoGroups[groupID]
        local clips = entry.Clips

        holo:setMaterial( entry.Material )
        submaterial.setSubMaterials( holo, entry.SubMaterials )
        holo:setColor( entry.Color or COLOR_DEFAULT )
        holo:setRenderMode( entry.RenderMode or RENDER_MODE_DEFAULT )
        holo:setSkin( entry.Skin or 0 )
        table.insert( holoGroup, holo )

        if clips then
            for i, clip in ipairs( clips ) do
                holo:setClip( i, true, clip.Origin, clip.Normal, holo )
            end
        end

        if entry.IsLast then
            local callback = holoGroupCallbacks[groupID]

            callback( holoGroup )

            holoGroups[groupID] = nil
            holoGroupCallbacks[groupID] = nil
            holoGroupOrigins[groupID] = nil
            holoGroupScales[groupID] = nil
        end
    end,
    nil,
    nil,
    0.1,
    0,
    0.75,
    "PtH_SpawnQueue"
)
